<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>30 Day Weather & Grid Forecast — ISO Load + Weather</title>
<meta name="description" content="ISO hourly load (EIA v2) with 30-day outlook + NWS hourly weather from ZIP." />
<style>
  :root{--bg:#0b0f17;--fg:#e8ecf3;--muted:#9aa7b1;--card:#111726;--accent:#4ea1ff}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:16px 20px;border-bottom:1px solid #1e2535;flex-wrap:wrap}
  h1{font-size:1.05rem;margin:0}
  .meta{color:var(--muted);font-size:.9rem}
  .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  select,input,button{background:#0e1524;color:var(--fg);border:1px solid #20304b;border-radius:10px;padding:8px 10px}
  button{cursor:pointer}
  main{padding:16px}
  .grid{display:grid;gap:16px}
  @media(min-width:1100px){.grid{grid-template-columns:1fr 1fr}}
  .card{background:var(--card);border:1px solid #1b2334;border-radius:16px;padding:16px;box-shadow:0 6px 20px rgba(0,0,0,.25)}
  .title{font-weight:600;margin:0 0 8px 0}
  #statusLoad,#statusWx{font-size:.9rem;color:var(--muted);margin-top:8px;min-height:1.4em}
  canvas{width:100%;height:440px;display:block}
  footer{padding:12px 20px;color:var(--muted);font-size:.85rem}
  a{color:var(--accent);text-decoration:none} a:hover{text-decoration:underline}
</style>
<!-- Only Chart.js (no date adapters needed) -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
<header>
  <div>
    <h1>30 Day Weather & Grid Forecast</h1>
    <div class="meta">Load: EIA v2 Actuals (D) + ISO Forecast (DF) + Climatology fill to 30d. Weather: NWS hourly from ZIP (≈7d).</div>
  </div>
  <div class="controls">
    <label>ISO
      <select id="isoSelect">
        <option value="CISO">CAISO</option><option value="PJM">PJM</option>
        <option value="MISO">MISO</option><option value="SPP">SPP</option>
        <option value="ISNE">ISO-NE</option><option value="NYIS">NYISO</option>
        <option value="ERCO">ERCOT</option>
      </select>
    </label>
    <label>History (days)
      <input id="histDays" type="number" min="7" max="60" step="1" value="7" />
    </label>
    <label>ZIP
      <input id="zipInput" type="text" inputmode="numeric" pattern="[0-9]{5}" placeholder="e.g., 90012" value="90012" />
    </label>
    <button id="runBtn">Run</button>
  </div>
</header>

<main>
  <div class="grid">
    <div class="card">
      <p class="title">ISO Load (Actuals + 30-Day Forecast)</p>
      <canvas id="loadChart"></canvas>
      <div id="statusLoad">Ready.</div>
    </div>
    <div class="card">
      <p class="title">Weather — Hourly Temp + Daily Min/Max</p>
      <canvas id="wxChart"></canvas>
      <div id="statusWx">Ready.</div>
    </div>
  </div>
</main>

<footer>
  EIA key embedded per request. Weather from NWS via ZIP (no key). NWS horizon is typically ~7 days.
</footer>

<script>
/* =========================
   Config & Utilities
========================= */
const EIA_API_KEY = 'DDtDBwdrxbGSSPNQBFP2JWvWDfSxTeVzg7qFWBfI';
const EIA_BASE = 'https://api.eia.gov/v2/electricity/rto/region-data/data/';
const STATUS_LOAD = document.getElementById('statusLoad');
const STATUS_WX = document.getElementById('statusWx');
const isoSelect = document.getElementById('isoSelect');
const histDaysInput = document.getElementById('histDays');
const zipInput = document.getElementById('zipInput');
const runBtn = document.getElementById('runBtn');

/* simple time formatters → strings (avoid date adapters) */
function pad(n){ return String(n).padStart(2,'0'); }
function toLabelLocal(d){
  // e.g., 2025-08-17 14:00
  return d.getFullYear()+'-'+pad(d.getMonth()+1)+'-'+pad(d.getDate())+' '+pad(d.getHours())+':'+pad(d.getMinutes());
}
function addHours(d,h){ return new Date(d.getTime() + h*3600*1000); }
function clone(d){ return new Date(d.getTime()); }
function toISOz(d){ return d.toISOString().replace(/\.\d{3}Z$/,'Z'); }
function fmtRangeLabels(labels){
  if (!labels.length) return '—';
  return labels[0]+' — '+labels[labels.length-1];
}
function fail(el, msg, err){
  console.error(msg, err || '');
  el.textContent = 'Error: ' + msg + (err && err.message ? ' — ' + err.message : '');
}

/* =========================
   EIA Fetch + Processing
========================= */
async function fetchEIA(paramsObj, maxPages=10) {
  const params = new URLSearchParams(paramsObj);
  params.set('api_key', EIA_API_KEY);
  if (!params.get('sort[0][column]')) {
    params.set('sort[0][column]', 'period');
    params.set('sort[0][direction]', 'asc');
  }
  let out=[], offset=0, length=5000;
  for (let i=0;i<maxPages;i++){
    params.set('offset', offset);
    params.set('length', length);
    const res = await fetch(EIA_BASE + '?' + params.toString());
    if (!res.ok) throw new Error('EIA ' + res.status + ' ' + res.statusText);
    const json = await res.json();
    const rows = (json && json.response && json.response.data) ? json.response.data : [];
    out = out.concat(rows);
    const total = (json && json.response && typeof json.response.total==='number') ? json.response.total : rows.length;
    offset += rows.length;
    if (offset >= total || rows.length === 0) break;
  }
  return out;
}

async function getActuals(region, start, end){
  const rows = await fetchEIA({
    'facets[type][]':'D',
    'facets[region][]': region,
    start: toISOz(start), end: toISOz(end)
  });
  const out=[];
  for (let i=0;i<rows.length;i++){
    const r = rows[i];
    const t = new Date(r.period);
    const v = Number(r.value);
    if (isFinite(t.getTime()) && isFinite(v)) out.push({ t, v });
  }
  return out;
}

async function getISOForecast(region, start, end){
  try{
    const rows = await fetchEIA({
      'facets[type][]':'DF',
      'facets[region][]': region,
      start: toISOz(start), end: toISOz(end)
    });
    const out=[];
    for (let i=0;i<rows.length;i++){
      const r = rows[i];
      const t = new Date(r.period);
      const v = Number(r.value);
      if (isFinite(t.getTime()) && isFinite(v)) out.push({ t, v });
    }
    return out;
  }catch(e){ console.warn('DF fetch failed', e); return []; }
}

// 3-year climatology fill for load
async function getClimatologyFill(region, targetStart, targetEnd) {
  const buckets = new Map();
  function push(d,val){
    const k = (d.getUTCMonth()+1)+'-'+d.getUTCDate()+'-'+d.getUTCHours();
    const arr = buckets.get(k); if (arr) arr.push(val); else buckets.set(k,[val]);
  }
  const years = [1,2,3];
  for (let yi=0; yi<years.length; yi++){
    const y = years[yi];
    const s = new Date(Date.UTC(targetStart.getUTCFullYear()-y, targetStart.getUTCMonth(), targetStart.getUTCDate(), targetStart.getUTCHours()));
    const e = new Date(Date.UTC(targetEnd.getUTCFullYear()-y, targetEnd.getUTCMonth(), targetEnd.getUTCDate(), targetEnd.getUTCHours()));
    try{
      const ser = await getActuals(region, s, e);
      for (let i=0;i<ser.length;i++) push(ser[i].t, ser[i].v);
    }catch(err){ console.warn('Climo year -'+y+' failed', err); }
  }
  const out=[];
  for (let t = clone(targetStart); t <= targetEnd; t = addHours(t,1)) {
    const k = (t.getUTCMonth()+1)+'-'+t.getUTCDate()+'-'+t.getUTCHours();
    const arr = buckets.get(k) || [];
    if (arr.length){
      let sum=0; for (let i=0;i<arr.length;i++) sum+=arr[i];
      out.push({ t: clone(t), v: sum/arr.length });
    }
  }
  return out;
}

async function build30DayForecast(region) {
  const now = new Date();
  const startF = addHours(now, 1), endF = addHours(now, 24*30);
  const df = await getISOForecast(region, startF, endF);
  const lastDF = df.length ? df[df.length-1].t : new Date(now.getTime());
  let clima = [];
  const needStart = addHours(lastDF, 1);
  if (needStart <= endF) clima = await getClimatologyFill(region, needStart, endF);
  const map = new Map(); for (let i=0;i<df.length;i++) map.set(+df[i].t, true);
  const merged = df.slice();
  for (let i=0;i<clima.length;i++) if (!map.has(+clima[i].t)) merged.push(clima[i]);
  merged.sort((a,b)=>a.t-b.t);
  return { series: merged, dfHours: df.length };
}

/* =========================
   Weather (NWS) from ZIP
========================= */
async function zipToLatLon(zip){
  const r = await fetch('https://api.zippopotam.us/us/' + zip);
  if (!r.ok) throw new Error('ZIP lookup failed');
  const j = await r.json();
  const place = j && j.places && j.places[0];
  if (!place) throw new Error('ZIP not found');
  return { lat: parseFloat(place.latitude), lon: parseFloat(place.longitude) };
}

async function getNwsEndpoints(lat, lon){
  const r = await fetch('https://api.weather.gov/points/' + lat + ',' + lon);
  if (!r.ok) throw new Error('NWS points lookup failed');
  const j = await r.json();
  return {
    hourly: j && j.properties ? j.properties.forecastHourly : null,
    city: j && j.properties && j.properties.relativeLocation ? j.properties.relativeLocation.properties.city : null,
    state: j && j.properties && j.properties.relativeLocation ? j.properties.relativeLocation.properties.state : null
  };
}

async function getHourlyTemps(hourlyUrl){
  const r = await fetch(hourlyUrl, { headers: { 'Accept': 'application/ld+json' }});
  if (!r.ok) throw new Error('NWS hourly forecast failed');
  const j = await r.json();
  const periods = j && j.properties ? (j.properties.periods || []) : [];
  const out=[];
  for (let i=0;i<periods.length;i++){
    const p = periods[i];
    const t = new Date(p.startTime);
    const v = Number(p.temperature);
    if (isFinite(t.getTime()) && isFinite(v)) out.push({ t, tempF: v });
  }
  return out;
}

function dailyMinMaxFromHourly(series){
  const byDay = new Map(), mins=[], maxs=[];
  for (let i=0;i<series.length;i++){
    const d = new Date(series[i].t);
    const k = d.getFullYear()+'-'+pad(d.getMonth()+1)+'-'+pad(d.getDate());
    const arr = byDay.get(k); if (arr) arr.push(series[i].tempF); else byDay.set(k,[series[i].tempF]);
  }
  const keys = Array.from(byDay.keys()).sort();
  for (let i=0;i<keys.length;i++){
    const k = keys[i], arr = byDay.get(k);
    const parts = k.split('-'); const t = new Date(parseInt(parts[0],10), parseInt(parts[1],10)-1, parseInt(parts[2],10), 12, 0, 0);
    let mn = arr[0], mx = arr[0];
    for (let j=1;j<arr.length;j++){ if (arr[j]<mn) mn=arr[j]; if (arr[j]>mx) mx=arr[j]; }
    mins.push({ x:t, y: mn }); maxs.push({ x:t, y: mx });
  }
  return { mins, maxs };
}

/* =========================
   Charts (adapter-free)
========================= */
let loadChart, wxChart;
function buildLineChart(ctx, label1, label2){
  return new Chart(ctx, {
    type:'line',
    data:{ labels:[], datasets:[
      { label: label1, data:[], borderWidth:2, tension:0.2, pointRadius:0 },
      { label: label2, data:[], borderWidth:2, tension:0.2, pointRadius:0, borderDash:[6,6] }
    ]},
    options:{
      responsive:true, maintainAspectRatio:false, interaction:{mode:'index',intersect:false},
      plugins:{ legend:{ labels:{ color:'#dbe6f2', usePointStyle:true } } },
      scales:{
        x:{ type:'category', ticks:{ color:'#b8c2cc', maxRotation:0, autoSkip:true, autoSkipPadding:16 }, grid:{color:'rgba(255,255,255,0.06)'} },
        y:{ ticks:{ color:'#b8c2cc' }, grid:{ color:'rgba(255,255,255,0.06)' } }
      }
    }
  });
}
function ensureLoadChart(){ if (loadChart) return loadChart; const ctx=document.getElementById('loadChart').getContext('2d'); loadChart=buildLineChart(ctx,'Actual Load (MW)','ISO Forecast (MW)'); return loadChart; }
function ensureWxChart(){ if (wxChart) return wxChart; const ctx=document.getElementById('wxChart').getContext('2d'); wxChart=buildLineChart(ctx,'Hourly Temp (°F)','Daily Min/Max (°F)'); return wxChart; }

/* =========================
   Render
========================= */
async function render(){
  const region = isoSelect.value;
  const histDays = Math.max(7, Math.min(60, parseInt(histDaysInput.value||'7',10)));
  const zip = (zipInput.value||'').trim();

  /* Load chart */
  STATUS_LOAD.textContent = 'Loading '+region+' actuals ('+histDays+'d) + 30-day forecast…';
  try{
    const now = new Date();
    const actuals = await getActuals(region, addHours(now,-24*histDays), now);
    const forecastObj = await build30DayForecast(region);

    // Convert timestamps → string labels
    const aLabels = actuals.map(p=> toLabelLocal(p.t));
    const aValues = actuals.map(p=> p.v);
    const fLabels = forecastObj.series.map(p=> toLabelLocal(p.t));
    const fValues = forecastObj.series.map(p=> p.v);

    // Merge label domain for category scale
    const labelSet = new Set(aLabels.concat(fLabels));
    const labels = Array.from(labelSet);
    labels.sort(); // lexicographic works with YYYY-MM-DD HH:mm

    const aBy = new Map(); for (let i=0;i<aLabels.length;i++) aBy.set(aLabels[i], aValues[i]);
    const fBy = new Map(); for (let i=0;i<fLabels.length;i++) fBy.set(fLabels[i], fValues[i]);

    const dsActuals=[], dsForecast=[];
    for (let i=0;i<labels.length;i++){
      const L = labels[i];
      dsActuals.push(aBy.has(L) ? aBy.get(L) : null);
      dsForecast.push(fBy.has(L) ? fBy.get(L) : null);
    }

    const lc = ensureLoadChart();
    lc.data.labels = labels;
    lc.data.datasets[0].data = dsActuals;
    lc.data.datasets[1].data = dsForecast;
    lc.update();

    STATUS_LOAD.textContent = 'Actuals: '+fmtRangeLabels(aLabels)+'; Forecast: '+fmtRangeLabels(fLabels)+' (ISO DF hours: '+forecastObj.dfHours+').';
  }catch(err){
    fail(STATUS_LOAD, 'Load series failed', err);
  }

  /* Weather chart */
  if (!/^[0-9]{5}$/.test(zip)) {
    STATUS_WX.textContent = 'Enter a 5-digit ZIP to load weather.';
    return;
  }
  STATUS_WX.textContent = 'Resolving weather for ZIP '+zip+'…';
  try{
    const loc = await zipToLatLon(zip);
    const ep = await getNwsEndpoints(loc.lat, loc.lon);
    if (!ep.hourly) throw new Error('NWS hourly URL not available for this point');
    const hourlyTemps = await getHourlyTemps(ep.hourly);

    const wxLabels = hourlyTemps.map(p=> toLabelLocal(p.t));
    const wxValues = hourlyTemps.map(p=> p.tempF);

    // Daily min/max markers collapsed to noon
    const m = dailyMinMaxFromHourly(hourlyTemps);
    const minBy = new Map(); for (let i=0;i<m.mins.length;i++) minBy.set(toLabelLocal(m.mins[i].x), m.mins[i].y);
    const maxBy = new Map(); for (let i=0;i<m.maxs.length;i++) maxBy.set(toLabelLocal(m.maxs[i].x), m.maxs[i].y);

    const labelSet = new Set(wxLabels.concat(Array.from(minBy.keys())).concat(Array.from(maxBy.keys())));
    const labels = Array.from(labelSet); labels.sort();

    const dsHourly=[], dsMin=[], dsMax=[];
    for (let i=0;i<labels.length;i++){
      const L = labels[i];
      dsHourly.push( (wxLabels.indexOf(L)>=0) ? wxValues[wxLabels.indexOf(L)] : null );
      dsMin.push( minBy.has(L) ? minBy.get(L) : null );
      dsMax.push( maxBy.has(L) ? maxBy.get(L) : null );
    }

    const wc = ensureWxChart();
    wc.data.labels = labels;
    wc.data.datasets[0].data = dsHourly;
    wc.data.datasets[1].data = dsMin;
    wc.data.datasets[2].data = dsMax;
    wc.data.datasets[1].borderDash = [6,6];
    wc.data.datasets[2].borderDash = [6,6];
    wc.update();

    STATUS_WX.textContent = 'Weather for '+(ep.city||'Location')+', '+(ep.state||'')+': '+fmtRangeLabels(wxLabels)+'. NWS hourly horizon is typically ~7 days.';
  }catch(err){
    fail(STATUS_WX, 'Weather series failed', err);
  }
}

runBtn.addEventListener('click', render);
window.addEventListener('DOMContentLoaded', render);
</script>
</body>
</html>
