<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ISO Load + Weather — 30-Day Forecast by ZIP</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='8' fill='%23121a33'/%3E%3Cpath d='M36 4L12 36h14l-2 24 30-38H38l-2-18z' fill='%234ea1ff'/%3E%3C/svg%3E">
  <meta name="description" content="Enter a US ZIP, get a 30‑day ISO load forecast (area for actual; dashed projection after horizon) + daily high/low temps (dotted). Updates hourly." />
  <style>
    :root{ --bg:#000000; --card:#121a33; --text:#eaf0ff; --muted:#000000; --accent:#4ea1ff; --danger:#ff4e4e; --grid:#1c274d; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:#000;color:var(--text)}
    header{padding:18px 16px;display:flex;gap:12px;align-items:center;flex-wrap:wrap;border-bottom:1px solid #111a33}
    h1{font-size:18px;margin:0;font-weight:700;letter-spacing:.2px}
    .sub{color:var(--muted);font-size:12px}
    .wrap{display:grid;gap:10px;padding:10px;max-width:900px;margin:0 auto}
    .card{background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));border:1px solid #1a2447;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:14px}
    label{display:block;font-weight:600;margin:0 0 8px;color:#cfe0ff}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    input[type="text"]{appearance:none;background:#00000;border:1px solid #000000;color:var(--text);padding:11px 14px;border-radius:12px;min-width:220px;font-size:14px;outline:none}
    button{all:unset;display:inline-flex;align-items:center;gap:8px;background:linear-gradient(180deg,#4ea1ff,#2f78ff);color:white;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 6px 16px rgba(46,119,255,.35)}
    button.secondary{background:#000000;border:1px solid #223061;color:#bcd0ff;box-shadow:none}
    .hint{color:var(--muted);font-size:12px}
    .status{display:flex;align-items:center;gap:8px;color:#bcd0ff}
    .dot{width:8px;height:8px;border-radius:50%}
    .dot.ok{background:#5ee}
    .dot.err{background:#000000}
    .badgelist{display:flex;flex-wrap:wrap;gap:8px}
    .badge{background:#0f1731;border:1px solid #223061;color:#bcd0ff;border-radius:100px;padding:4px 8px;font-size:12px}

    /* Exact chart size target: 8in x 6in (falls back responsively) */
    .chartbox{width:8in;max-width:100%;height:6in;max-height:6in;margin:0 auto}
    .chartbox>canvas{width:100% !important;height:100% !important;background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));border-radius:12px;border:1px solid #1a2447}
    body.compact .chartbox{width:6in;height:4.5in}

    footer{color:#93a7d9;font-size:12px;display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    code,kbd{background:#0f1731;border:1px solid #223061;color:#bcd0ff;border-radius:6px;padding:0 6px}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>ISO Load + Weather — 30-Day Forecast</h1>
      <div class="sub">Auto-updates hourly. Beyond the ISO horizon, load is a temperature‑driven projection (dashed).</div>
    </div>
  </header>

  <main class="wrap">
    <section class="card">
      <label for="zip">Enter a US ZIP code</label>
      <div class="row">
        <input id="zip" type="text" inputmode="numeric" pattern="[0-9]{5}" maxlength="10" placeholder="e.g., 94102" autocomplete="postal-code" />
        <button id="go">Get forecast</button>
        <button id="loc" class="secondary" title="Use your approximate location (browser prompt)">Use my location</button>
        <select id="isoSelect" class="secondary" title="Force a specific ISO (optional)" style="padding:10px 12px;border-radius:12px;border:1px solid #223061;background:#0f1731;color:#bcd0ff">
          <option value="auto">Auto-detect ISO</option>
          <option value="CAISO">CAISO</option>
          <option value="ERCOT">ERCOT</option>
          <option value="PJM">PJM</option>
          <option value="MISO">MISO</option>
          <option value="SPP">SPP</option>
          <option value="ISONE">ISO-NE</option>
          <option value="NYISO">NYISO</option>
        </select>
      </div>
      <div class="hint">Blue area = ISO load forecast (MW, left). Dashed blue = projected load after ISO horizon. ▲ markers = daily peaks. Red dotted = daily high. Dark‑blue dotted = daily low (°F, right).</div>
    </section>

    <section class="card">
      <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
        <div id="where" class="status">—</div>
        <div class="row" style="gap:10px;align-items:center">
          <div class="badgelist">
            <span class="badge" id="badge-iso">ISO: —</span>
            <span class="badge" id="badge-src">Source: —</span>
            <span class="badge" id="badge-upd">Last update: —</span>
          </div>
          <button id="dlcsv" class="secondary" title="Download the plotted data as CSV">Download CSV</button>
          <button id="compact" class="secondary" title="Toggle compact chart height">Compact view</button>
        </div>
      </div>
      <div class="chartbox"><canvas id="chart" aria-label="Load and temperature forecast" role="img"></canvas></div>
      <div class="hint" id="note"></div>
    </section>

    <section class="card">
      <details>
        <summary><strong>About & Data Sources</strong></summary>
        <p><strong>Load forecasts</strong> (hourly unless noted): CAISO 10‑day CSV; ERCOT 6‑day JSON; NYISO daily ISO‑LF; SPP MTLF 7‑day; ISO‑NE 3‑day. <em>Beyond each ISO horizon, this page projects load from temperature using a simple linear model fit to the overlapping days, then applies a generic hourly shape.</em></p>
        <p><strong>Weather</strong> (daily hi/lo): Open‑Meteo forecast (first 16 days) + Open‑Meteo archive (last year, same dates) as a climatology proxy for days 17‑30. No keys.</p>
        <p class="hint">If an ISO blocks CORS, a safe proxy mirror is tried. Projections are illustrative only.</p>
        <details>
          <summary>Diagnostics (dev only)</summary>
          <button id="runtests" class="secondary">Run self‑tests</button>
          <div id="testout" class="hint"></div>
        </details>
      </details>
    </section>

    <footer class="card">
      <div>Credits: CAISO; ERCOT Dashboards; NYISO MIS; SPP Marketplace; ISO‑NE ISO‑Express; Open‑Meteo (forecast & archive).</div>
      <div>Static hosting — no API keys, no server.</div>
    </footer>
  </main>

  <!-- Libraries (no-build, CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
  // ======= Tiny util =======
  const $ = sel => document.querySelector(sel);
  const fmt = new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' });

  // ======= Fetch + CORS helpers (proxy‑first to avoid console CORS noise) =======
  const GEOCODE = name => `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(name)}&count=1&language=en&format=json&country=US`;
  const WEATHER16 = (lat, lon) => `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=temperature_2m_max,temperature_2m_min&temperature_unit=fahrenheit&timezone=auto&forecast_days=16`;
  const ARCHIVE = (lat, lon, start, end) => `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}&start_date=${start}&end_date=${end}&daily=temperature_2m_max,temperature_2m_min&temperature_unit=fahrenheit&timezone=auto`;
  const withCORSProxy = (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
  const viaJina = (url) => { const bare = url.replace(/^https?:\/\//,''); return [`https://r.jina.ai/http://${bare}`, `https://r.jina.ai/https://${bare}`]; };

  async function fetchTextWithFallbacks(urls) {
    const errors = [];
    for (const url of urls) {
      const attempts = [...viaJina(url), withCORSProxy(url), url];
      for (const u of attempts) {
        try { const r = await fetch(u, { cache:'no-store' }); if (r.ok) return await r.text(); errors.push(`${u} → HTTP ${r.status}`); }
        catch(e){ errors.push(`${u} → ${e?.message||e}`); }
      }
    }
    throw new Error('All fetches failed\n' + errors.join('\n'));
  }

  async function fetchJSONWithFallback(url) {
    const attempts = [...viaJina(url), withCORSProxy(url), url];
    const errors = [];
    for (const u of attempts) {
      try {
        const r = await fetch(u, { cache:'no-store' });
        if (!r.ok) { errors.push(`${u} → HTTP ${r.status}`); continue; }
        try { return await r.json(); }
        catch { const t = await r.text(); return JSON.parse(t); }
      } catch(e){ errors.push(`${u} → ${e?.message||e}`); }
    }
    throw new Error('Fetch failed\n' + errors.join('\n'));
  }

  // ======= ISO detectors =======
  const stateToISO = (stateCode) => {
    const PJM_STATES = new Set(['DC','DE','IL','IN','KY','MD','MI','NJ','NC','OH','PA','TN','VA','WV']);
    const MISO_STATES = new Set(['AR','IL','IN','IA','KY','LA','MI','MN','MO','MS','MT','ND','SD','TX','WI']);
    const SPP_STATES  = new Set(['AR','KS','LA','MN','MO','MT','ND','NE','NM','OK','SD','TX','WY']);
    const ISONE_STATES= new Set(['CT','MA','ME','NH','RI','VT']);
    if (stateCode === 'CA') return 'CAISO';
    if (stateCode === 'TX') return 'ERCOT';
    if (stateCode === 'NY') return 'NYISO';
    if (ISONE_STATES.has(stateCode)) return 'ISONE';
    if (SPP_STATES.has(stateCode)) return 'SPP';
    if (PJM_STATES.has(stateCode)) return 'PJM';
    if (MISO_STATES.has(stateCode)) return 'MISO';
    return 'UNKNOWN';
  };

  // ======= State name → code helper =======
  function stateNameToCode(name){
    const map={ 'Alabama':'AL','Alaska':'AK','Arizona':'AZ','Arkansas':'AR','California':'CA','Colorado':'CO','Connecticut':'CT','Delaware':'DE','Florida':'FL','Georgia':'GA','Hawaii':'HI','Idaho':'ID','Illinois':'IL','Indiana':'IN','Iowa':'IA','Kansas':'KS','Kentucky':'KY','Louisiana':'LA','Maine':'ME','Maryland':'MD','Massachusetts':'MA','Michigan':'MI','Minnesota':'MN','Mississippi':'MS','Missouri':'MO','Montana':'MT','Nebraska':'NE','Nevada':'NV','New Hampshire':'NH','New Jersey':'NJ','New Mexico':'NM','New York':'NY','North Carolina':'NC','North Dakota':'ND','Ohio':'OH','Oklahoma':'OK','Oregon':'OR','Pennsylvania':'PA','Rhode Island':'RI','South Carolina':'SC','South Dakota':'SD','Tennessee':'TN','Texas':'TX','Utah':'UT','Vermont':'VT','Virginia':'VA','Washington':'WA','West Virginia':'WV','Wisconsin':'WI','Wyoming':'WY','District of Columbia':'DC' };
    return map[name] || '';
  }

  // ======= Geolocation helpers (robust, user-friendly) =======
  function explainGeoError(err){
    const code = err && typeof err === 'object' && 'code' in err ? err.code : 0;
    if (code === 1) return 'Location permission was denied. Enable it in your browser and try again, or enter a ZIP.';
    if (code === 2) return 'Location unavailable (no GPS/IP fix). Check your connection or enter a ZIP.';
    if (code === 3) return 'Location request timed out. Try again or enter a ZIP.';
    if (err && err.message) return 'Location error: ' + err.message;
    return 'Location request failed. Enter a ZIP code instead.';
  }

  function geoLocate(options={}){
    return new Promise((resolve, reject)=>{
      if (!('geolocation' in navigator)) return reject({ code:0, message:'Geolocation is not supported by this browser' });
      const merged = Object.assign({ enableHighAccuracy:false, maximumAge:60000, timeout:10000 }, options||{});
      navigator.geolocation.getCurrentPosition(
        pos => resolve(pos),
        err => reject(err),
        merged
      );
    });
  }

  // ======= Nearest ZIP helpers =======
  function haversineKm(lat1, lon1, lat2, lon2){
    const toRad = x => x * Math.PI / 180;
    const dLat = toRad(lat2 - lat1), dLon = toRad(lon2 - lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    return 2 * 6371 * Math.asin(Math.sqrt(a));
  }
  async function nearestZipFromCoords(lat, lon, cityHint = '', stateCodeHint = ''){
    // 1) Try OSM Nominatim reverse to get a postcode directly
    try{
      const j = await fetchJSONWithFallback(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}`);
      const pc = (j?.address?.postcode || '').split(' ')[0];
      if (/^[0-9]{5}$/.test(pc)) return pc;
    }catch(_e){}
    // 2) Fall back to Zippopotam.us for city/state and choose nearest place by coords
    try{
      const city = (cityHint||'').trim();
      const st = (stateCodeHint||'').trim();
      if (!city || !st) return '';
      const j2 = await fetchJSONWithFallback(`https://api.zippopotam.us/us/${encodeURIComponent(st)}/${encodeURIComponent(city)}`);
      const places = j2?.places || [];
      if (!Array.isArray(places) || places.length===0) return '';
      let bestZip='', bestD=Infinity;
      for(const p of places){
        const plat=Number(p.latitude), plon=Number(p.longitude);
        const d=haversineKm(lat,lon,plat,plon);
        if (d<bestD && /^[0-9]{5}$/.test(p['post code'])){ bestD=d; bestZip=p['post code']; }
      }
      return bestZip || '';
    }catch(_e){ return ''; }
  }
  function setURLParam(key, val){
    try{
      const u=new URL(location.href);
      if(val==null||val==='') u.searchParams.delete(key); else u.searchParams.set(key,String(val));
      history.replaceState(null,'',u);
    }catch{}
  }

  // ======= Geocoding helper used by UI (ZIP or place text) =======
  async function geocodeZipOrText(q){
    const s = String(q||'').trim();
    if (!s) throw new Error('Please enter a ZIP or place');
    if (/^\d{5}$/.test(s)){
      // Prefer ZIP database first (good for precise coords)
      try{
        const j = await fetchJSONWithFallback(`https://api.zippopotam.us/us/${s}`);
        const place = j?.places?.[0];
        if (place){
          return {
            name: place['place name'] || s,
            state: place['state'] || '',
            stateCode: place['state abbreviation'] || '',
            country: 'US',
            lat: Number(place['latitude']),
            lon: Number(place['longitude'])
          };
        }
      }catch(_e){ /* fall through to Open‑Meteo */ }
    }
    // Fallback to Open‑Meteo geocoder (names + many ZIPs)
    const j2 = await fetchJSONWithFallback(GEOCODE(s));
    if (!j2.results || !j2.results.length) throw new Error('Location not found');
    const r = j2.results[0];
    return {
      name: r.name,
      state: r.admin1 || r.admin2 || '',
      stateCode: stateNameToCode(r.admin1 || ''),
      country: (r.country_code||'US').toUpperCase(),
      lat: r.latitude,
      lon: r.longitude
    };
  }

  // ======= ISO load sources =======
  const CAISO_CSV_URLS = [
    'https://www.caiso.com/outlook/SP/Load/LoadForecast.csv',
    'https://content.caiso.com/outlook/SP/Load/LoadForecast.csv',
    'https://www.caiso.com/outlook/SP/Load/loadforecast.csv',
    'https://content.caiso.com/outlook/SP/Load/loadforecast.csv',
    'http://www.caiso.com/outlook/SP/Load/LoadForecast.csv',
    'http://content.caiso.com/outlook/SP/Load/LoadForecast.csv',
    'http://www.caiso.com/outlook/SP/Load/loadforecast.csv',
    'http://content.caiso.com/outlook/SP/Load/loadforecast.csv'
  ];

  function parseCAISOCsv(text){
    const parsed = Papa.parse(text.trim(), { header:true });
    if (!parsed.data || !parsed.data.length) throw new Error('Empty CSV');
    const rows = parsed.data;
    const headers = (parsed.meta.fields||[]).map(h => (h||'').trim());
    const timeKey = headers.find(h => /time|timestamp|datetime/i.test(h)) || (headers.includes('Date') && headers.includes('HE') ? 'Date' : null);
    const mwKey = headers.find(h => /mw|forecast|load/i.test(h) && !/net|price|temp|solar|wind/i.test(h));
    if (!mwKey) throw new Error('Could not find MW column in CAISO CSV');
    const out = [];
    for (const r of rows){
      let t=null;
      if (timeKey === 'Date' && r.Date && r.HE){
        const he = Number(r.HE); if (!Number.isFinite(he)) continue;
        const d = new Date(r.Date); if (isNaN(d)) continue; d.setHours(he-1,0,0,0); t=d;
      } else if (timeKey && r[timeKey]){ const d = new Date(r[timeKey]); if (!isNaN(d)) t=d; }
      else continue;
      const y = Number(String(r[mwKey]).replace(/,/g,''));
      if (Number.isFinite(y)) out.push({ x:t, y });
    }
    out.sort((a,b)=>a.x-b.x); return out;
  }

  async function fetchERCOT(){
    try{
      const j = await fetchJSONWithFallback('https://www.ercot.com/api/1/services/read/dashboards/supply-demand.json');
      const series = (j?.data || j?.currentDay || j?.sixDay || []).data || j?.data || [];
      const baseDate = new Date((j.lastUpdated||'').slice(0,10));
      const pts=[]; let cur = new Date(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate());
      for (const r of series){ const t = r.timestamp? new Date(r.timestamp): new Date(cur); if(!r.timestamp) cur = new Date(cur.getTime()+5*60*1000); const y = Number(r.demand ?? r.systemLoad ?? r.forecastedLoad ?? r.Load ?? r.load); if(Number.isFinite(y)) pts.push({x:t,y}); }
      const hourly=[]; let last=null; for(const p of pts){ const key=p.x.toISOString().slice(0,13); if(last?.key===key) last.p=p; else { if(last) hourly.push(last.p); last={key,p}; } } if(last) hourly.push(last.p);
      return { points: hourly, source: 'ERCOT dashboards supply-demand.json' };
    }catch{}
    const j2 = await fetchJSONWithFallback('https://www.ercot.com/api/1/services/read/dashboards/todays-outlook.json');
    const d0 = new Date((j2.lastUpdated||'').slice(0,10));
    const pts=[]; let cur = new Date(d0.getFullYear(), d0.getMonth(), d0.getDate());
    for (const r of (j2.data||[])){ const t=new Date(cur); cur=new Date(cur.getTime()+5*60*1000); const y=Number(r.demand ?? r.systemLoad ?? r.forecastedLoad ?? r.Load ?? r.load); if(Number.isFinite(y)) pts.push({x:t,y}); }
    const hourly=[]; let last=null; for(const p of pts){ const key=p.x.getHours(); if(last?.key===key) last.p=p; else { if(last) hourly.push(last.p); last={key,p}; } } if(last) hourly.push(last.p);
    return { points: hourly, source: 'ERCOT dashboards todays-outlook.json' };
  }

  function yyyyMMdd(d){ const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,'0'); const day=String(d.getDate()).padStart(2,'0'); return `${y}${m}${day}`; }
  async function fetchNYISO(){
    const candidates=[]; const today=new Date();
    for(let k=0;k<2;k++){ const d=new Date(today.getTime()+k*86400000); candidates.push(`https://mis.nyiso.com/public/csv/isolf/${yyyyMMdd(d)}isolf.csv`); }
    const csv = await fetchTextWithFallbacks(candidates);
    const parsed = Papa.parse(csv.trim(), { header:true }); const fields=(parsed.meta.fields||[]).map(s=>String(s).trim());
    const timeKey = fields.find(f=>/time|timestamp|date/i.test(f)) || fields[0]; let nycaKey = fields.find(f=>/NYCA|NYISO|NYCA Load/i.test(f));
    const out=[]; for (const r of parsed.data){ const t = new Date(r[timeKey]); if(isNaN(t)) continue; let y; if(nycaKey) y=Number(String(r[nycaKey]).replace(/,/g,'')); else { y=0; let ok=false; for(const k of fields){ if(k===timeKey) continue; const v=Number(String(r[k]).replace(/,/g,'')); if (Number.isFinite(v)) { y+=v; ok=true; } } if(!ok) continue; } if(Number.isFinite(y)) out.push({x:t,y}); }
    out.sort((a,b)=>a.x-b.x); return { points: out, source: 'NYISO ISO Load Forecast (isolf)' };
  }

  function formatSPPPath(dt){ const y=dt.getFullYear(); const m=String(dt.getMonth()+1).padStart(2,'0'); const d=String(dt.getDate()).padStart(2,'0'); const H=String(dt.getHours()).padStart(2,'0'); return `/${y}/${m}/${d}/OP-MTLF-${y}${m}${d}${H}00.csv`; }
  async function fetchSPP(){
    const base='https://portal.spp.org/file-browser-api/download?path='; const tries=[]; const now=new Date();
    for(let i=0;i<8;i++){ const d=new Date(now.getTime()-i*3600000); tries.push(base+encodeURIComponent(formatSPPPath(d))); }
    const csv = await fetchTextWithFallbacks(tries);
    const parsed = Papa.parse(csv.trim(), { header:true }); const fields=(parsed.meta.fields||[]).map(f=>String(f).trim());
    const timeKey = fields.find(f=>/interval|time/i.test(f)) || fields[0]; const mwKey = fields.find(f=>/MTLF|Forecast|Load/i.test(f) && !/Actual/i.test(f)) || fields[1];
    const out=[]; for(const r of parsed.data){ const t=new Date(r[timeKey]); const y=Number(String(r[mwKey]).replace(/,/g,'')); if(!isNaN(t)&&Number.isFinite(y)) out.push({x:t,y}); }
    out.sort((a,b)=>a.x-b.x); return { points: out, source: 'SPP OP-MTLF (7-day hourly)' };
  }

  async function fetchISONE(){
    const listUrl='https://www.iso-ne.com/isoexpress/web/reports/load-and-demand/-/tree/three-day-reliability-region-demand-forecast';
    const html = await fetchTextWithFallbacks([listUrl]);
    const doc = new DOMParser().parseFromString(html, 'text/html'); const a = doc.querySelector('a[href*="transform/csv"]');
    if(!a) throw new Error('ISO-NE CSV link not found');
    const csvUrl = new URL(a.getAttribute('href'), 'https://www.iso-ne.com').toString();
    const csv = await fetchTextWithFallbacks([csvUrl]);
    const parsed = Papa.parse(csv.trim(), { header:true }); const fields=(parsed.meta.fields||[]).map(f=>String(f).trim());
    const timeKey = fields.find(f=>/Hour|Time|Date/i.test(f)) || fields[0]; const mwKey = fields.find(f=>/System Load|Demand|MWh|MW/i.test(f) && !/Prior/i.test(f)) || fields[fields.length-1];
    const out=[]; for(const r of parsed.data){ const t=new Date(r[timeKey]); const y=Number(String(r[mwKey]).replace(/,/g,'')); if(!isNaN(t)&&Number.isFinite(y)) out.push({x:t,y}); }
    out.sort((a,b)=>a.x-b.x); return { points: out, source: 'ISO-NE Three-Day System Demand Forecast' };
  }

  async function fetchPJM(){
    try{
      const j = await fetchJSONWithFallback('https://dataminer2.pjm.com/feed/load_frcstd_7_day');
      const rows=j?.rows||j?.data||[]; const out=[]; for(const r of rows){ const t=new Date(r.effective_date||r.datetime_beginning_utc||r.datetime_beginning_ept||r.datetime_beginning||r.interval_start); const y=Number(String(r.rto_total??r.rto??r.rto_load??r.total_forecast_mw??r.load_mw??r.frcstd_load).replace(/,/g,'')); if(!isNaN(t)&&Number.isFinite(y)) out.push({x:t,y}); }
      if(out.length){ out.sort((a,b)=>a.x-b.x); return { points: out, source: 'PJM Data Miner 2 — Seven-Day Load Forecast' }; }
    }catch{}
    try{
      const j2 = await fetchJSONWithFallback('https://dataminer2.pjm.com/feed/very_short_load_frcst');
      const rows=j2?.rows||j2?.data||[]; const out=[]; for(const r of rows){ const t=new Date(r.datetime_beginning_ept||r.datetime_beginning_utc||r.effective_date); const y=Number(String(r.rto_frcst??r.frcst??r.load_mw).replace(/,/g,'')); if(!isNaN(t)&&Number.isFinite(y)) out.push({x:t,y}); }
      if(out.length){ out.sort((a,b)=>a.x-b.x); return { points: out, source: 'PJM very short load forecast (2-hour)' }; }
    }catch{}
    return { points: [], source: 'PJM public feed not reachable (may require account)' };
  }

  async function fetchMISO(){ return { points: [], source: 'MISO: no keyless multi-day hourly load forecast endpoint available' }; }

  async function fetchLoadForecastForISO(iso){
    if (iso==='CAISO'){ const csv=await fetchTextWithFallbacks(CAISO_CSV_URLS); return { points: parseCAISOCsv(csv), source:'CAISO LoadForecast.csv' }; }
    if (iso==='ERCOT') return await fetchERCOT();
    if (iso==='NYISO') return await fetchNYISO();
    if (iso==='SPP')   return await fetchSPP();
    if (iso==='ISONE') return await fetchISONE();
    if (iso==='PJM')   return await fetchPJM();
    if (iso==='MISO')  return await fetchMISO();
    return { points: [], source:'No public source wired for this ISO yet' };
  }

  // ======= Weather to 30 days: 16-day forecast + 14-day climatology (last year same dates) =======
  function ymd(d){ return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
  function addDays(d, n){ const t=new Date(d); t.setDate(t.getDate()+n); return t; }

  async function fetchWeather30(lat, lon){
    const j = await fetchJSONWithFallback(WEATHER16(lat, lon));
    const daily = j.daily || { time:[], temperature_2m_max:[], temperature_2m_min:[] };
    const outTime = [], outMax = [], outMin = [];
    const today = new Date(); today.setHours(0,0,0,0);
    const n1 = Math.min(16, daily.time?.length||0);
    for(let i=0;i<n1;i++){ outTime.push( ymd(addDays(today, i)) ); outMax.push(daily.temperature_2m_max[i]); outMin.push(daily.temperature_2m_min[i]); }

    if (outTime.length < 30){
      // Need days 17..30 from last year's archive for same month/day
      const needed = [];
      for(let i=outTime.length;i<30;i++){ const d=addDays(today,i); const ly=new Date(d); ly.setFullYear(d.getFullYear()-1); needed.push(ly); }
      // Single range covering min..max last-year dates
      needed.sort((a,b)=>a-b);
      const start = ymd(needed[0]); const end = ymd(needed[needed.length-1]);
      const a = await fetchJSONWithFallback(ARCHIVE(lat, lon, start, end));
      const map = new Map();
      for(let i=0;i<(a.daily?.time?.length||0);i++){ map.set(a.daily.time[i], { hi:a.daily.temperature_2m_max[i], lo:a.daily.temperature_2m_min[i] }); }
      for(let i=outTime.length;i<30;i++){
        const d = addDays(today,i); const ly = new Date(d); ly.setFullYear(d.getFullYear()-1); const key=ymd(ly);
        const rec = map.get(key) || null;
        const hi = (rec?.hi ?? outMax[outMax.length-1] ?? 70);
        const lo = (rec?.lo ?? outMin[outMin.length-1] ?? 55);
        outTime.push( ymd(d) ); outMax.push(hi); outMin.push(lo);
      }
    }
    return { time: outTime, temperature_2m_max: outMax, temperature_2m_min: outMin };
  }

  // ======= Chart helpers =======
  let chart; let lastData = { load: [], proj: [], dailyHi: [], dailyLo: [], peaks: [], iso:'', loc:null };

  function buildChart(ctx, seriesLoad, seriesProj, seriesHi, seriesLo, dailyPeaks){
    if (chart) chart.destroy();
    const start = new Date(); start.setHours(0,0,0,0);
    const end = new Date(start); end.setDate(end.getDate()+30); end.setHours(23,59,59,999);

    const gradient = ctx.createLinearGradient(0,0,0,ctx.canvas.height); gradient.addColorStop(0,'rgba(78,161,255,0.45)'); gradient.addColorStop(1,'rgba(78,161,255,0.05)');
    const datasets = [
      { label:'ISO Load Forecast (MW)',
        data: seriesLoad,
        parsing:false,
        borderColor:'#4ea1ff',
        borderWidth:2,
        backgroundColor: gradient,
        fill:true,
        tension:0.25,
        pointRadius:0,
        yAxisID:'yMW',
        pointStyle:'line'
      },
      { label:'Projected Load (model)',
        data: seriesProj,
        parsing:false,
        borderColor:'#4ea1ff',
        borderDash:[4,4],
        borderWidth:2,
        fill:false,
        tension:0.25,
        pointRadius:0,
        yAxisID:'yMW',
        pointStyle:'line'
      },
      { label:'Daily High (°F)',
        data: seriesHi,
        parsing:false,
        borderColor:'#ff4e4e',
        borderDash:[6,6],
        borderWidth:2,
        fill:false,
        pointRadius:0,
        yAxisID:'yT',
        pointStyle:'line'
      },
      { label:'Daily Low (°F)',
        data: seriesLo,
        parsing:false,
        borderColor:'#2d5cff',
        borderDash:[6,6],
        borderWidth:2,
        fill:false,
        pointRadius:0,
        yAxisID:'yT',
        pointStyle:'line'
      }
    ];
    if (dailyPeaks && dailyPeaks.length) datasets.push({ label:'Daily Peak (MW)', type:'scatter', data:dailyPeaks, parsing:false, borderColor:'#4ea1ff', backgroundColor:'#fff', pointStyle:'triangle', pointRadius:5, pointHoverRadius:7, yAxisID:'yMW' });

    chart = new Chart(ctx, {
      type:'line', data:{ datasets }, options:{ responsive:true, maintainAspectRatio:false, interaction:{ mode:'index', intersect:false },
        scales:{ x:{ type:'time', min:start, max:end, time:{ unit:'day', tooltipFormat:'MMM d, h a' }, grid:{ color:'rgba(255,255,255,0.05)' }, ticks:{ color:'#cfe0ff' } },
                 yMW:{ type:'linear', position:'left', title:{ display:true, text:'Megawatts (MW)' }, grid:{ color:'rgba(255,255,255,0.06)' }, ticks:{ color:'#cfe0ff' } },
                 yT:{ type:'linear', position:'right', title:{ display:true, text:'Temperature (°F)' }, grid:{ drawOnChartArea:false }, ticks:{ color:'#cfe0ff' } } },
        plugins:{ legend:{ labels:{ color:'#d9e4ff', usePointStyle:true, pointStyleWidth:28, boxWidth:28, boxHeight:2, padding:12, generateLabels(chart){ const base = Chart.defaults.plugins.legend.labels.generateLabels(chart); base.forEach(li => { const ds = chart.data.datasets[li.datasetIndex]; if (ds && ds.type === 'scatter') { li.pointStyle = 'triangle'; li.lineDash = []; li.lineWidth = 0; } else { li.pointStyle = 'line'; li.lineDash = [6,4]; li.lineWidth = 2; } }); return base; } } }, tooltip:{ callbacks:{ label:(ctx)=>{ const v=ctx.raw?.y ?? ctx.parsed.y; const lbl=ctx.dataset.label||''; return /Load|Peak/.test(lbl) ? `${lbl}: ${Math.round(v).toLocaleString()} MW` : `${lbl}: ${Math.round(v)} °F`; } } } }
      }
    });
  }

  function dateKeyLocal(d){ return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
  function computeDailyPeaks(points){ const byDay=new Map(); for(const p of points){ const k=dateKeyLocal(p.x); const cur=byDay.get(k); if(!cur||p.y>cur.y) byDay.set(k,{x:p.x,y:p.y}); } return Array.from(byDay.values()).sort((a,b)=>a.x-b.x); }

  function prepareDailyTemps(daily, want=30){
    const hi=[], lo=[]; const n = Math.min(want, daily.time.length);
    for(let i=0;i<n;i++){ const d=new Date(daily.time[i]+'T12:00:00'); hi.push({x:d,y:daily.temperature_2m_max[i]}); lo.push({x:d,y:daily.temperature_2m_min[i]}); }
    return { outHi:hi, outLo:lo };
  }

  function limitToHorizon(points,days=30){ const now=new Date(); const end=new Date(now.getTime()+days*86400000); return points.filter(p=>p.x>=now && p.x<=end); }
  function formatLocalISO(d){ const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,'0'); const day=String(d.getDate()).padStart(2,'0'); const hh=String(d.getHours()).padStart(2,'0'); const mm=String(d.getMinutes()).padStart(2,'0'); const ss=String(d.getSeconds()).padStart(2,'0'); return `${y}-${m}-${day} ${hh}:${mm}:${ss}`; }

  // ======= Simple temp→peak model and projection =======
  function fitLinear(x, y){ // y ≈ a + b*x
    const n = Math.min(x.length, y.length); if(n<3) return null;
    let sx=0, sy=0, sxx=0, sxy=0; for(let i=0;i<n;i++){ const xi=x[i]; const yi=y[i]; sx+=xi; sy+=yi; sxx+=xi*xi; sxy+=xi*yi; }
    const denom = (n*sxx - sx*sx); if (Math.abs(denom) < 1e-6) return null;
    const b = (n*sxy - sx*sy) / denom; const a = (sy - b*sx) / n; return {a,b};
  }
  function defaultShape(){ // normalized typical daily shape, peak=1 around 17:00
    const s=[0.65,0.62,0.6,0.6,0.62,0.68,0.75,0.82,0.88,0.92,0.94,0.95,0.96,0.97,0.98,0.99,1.00,0.98,0.95,0.9,0.85,0.8,0.75,0.7];
    const m=Math.max(...s); return s.map(v=>v/m);
  }
  function projectFromTemps(dailyHi, dailyLo, knownPeaks){
    // Build training pairs where both peak and temps exist
    const tMeanByDay = new Map(); for(let i=0;i<dailyHi.length;i++){ const k=dateKeyLocal(dailyHi[i].x); tMeanByDay.set(k, (dailyHi[i].y + (dailyLo[i]?.y ?? dailyHi[i].y))/2 ); }
    const x=[], y=[]; let lastPeakDay=null;
    for(const p of knownPeaks){ const k=dateKeyLocal(p.x); if(tMeanByDay.has(k)){ x.push(tMeanByDay.get(k)); y.push(p.y); lastPeakDay = p.x; } }
    const model = fitLinear(x,y);
    if (!model) return { series: [], lastPeakDay };
    // Predict for days after the last known peak day
    const shape = defaultShape(); const out=[];
    for(let i=0;i<dailyHi.length;i++){
      const d = dailyHi[i].x; if (!lastPeakDay || d<= lastPeakDay) continue;
      const k = dateKeyLocal(d); const tmean = tMeanByDay.get(k); if (tmean==null) continue;
      const peak = Math.max(0, model.a + model.b * tmean);
      const base = new Date(d); base.setHours(0,0,0,0);
      for(let h=0; h<24; h++){ const t=new Date(base); t.setHours(h,0,0,0); out.push({ x:t, y: peak * shape[h] }); }
    }
    return { series: out, lastPeakDay };
  }

  function makeCSV(last){
    const lines=[];
    if (last.load && last.load.length){
      lines.push(['timestamp_local','timestamp_utc','date_local','iso','location','state_code','latitude','longitude','load_mw','proj_load_mw','daily_high_f','daily_low_f'].join(','));
      const hiMap=Object.fromEntries((last.dailyHi||[]).map(p=>[dateKeyLocal(p.x),p.y]));
      const loMap=Object.fromEntries((last.dailyLo||[]).map(p=>[dateKeyLocal(p.x),p.y]));
      const projMap=new Map((last.proj||[]).map(p=>[p.x.toISOString(), p.y]));
      for(const p of last.load){ const d=p.x; const dk=dateKeyLocal(d); const isoUtc=new Date(d.getTime()-d.getTimezoneOffset()*60000).toISOString(); lines.push([ formatLocalISO(d), isoUtc.replace('T',' ').replace('Z',''), dk, last.iso||'', (last.loc?.name||'') + (last.loc?.state ? ', ' + last.loc.state : ''), last.loc?.stateCode||'', last.loc?.lat?.toFixed?.(4)||'', last.loc?.lon?.toFixed?.(4)||'', Math.round(p.y), projMap.get(d.toISOString())??'', hiMap[dk]??'', loMap[dk]??'' ].join(',')); }
      // Also append projected-only rows not overlapping actual
      const lastActual = last.load.length ? last.load[last.load.length-1].x : null;
      for(const p of (last.proj||[])){ if(lastActual && p.x<=lastActual) continue; const d=p.x; const dk=dateKeyLocal(d); const isoUtc=new Date(d.getTime()-d.getTimezoneOffset()*60000).toISOString(); lines.push([ formatLocalISO(d), isoUtc.replace('T',' ').replace('Z',''), dk, last.iso||'', (last.loc?.name||'') + (last.loc?.state ? ', ' + last.loc.state : ''), last.loc?.stateCode||'', last.loc?.lat?.toFixed?.(4)||'', last.loc?.lon?.toFixed?.(4)||'', '', Math.round(p.y), hiMap[dk]??'', loMap[dk]??'' ].join(',')); }
    } else {
      lines.push(['date_local','iso','location','state_code','latitude','longitude','daily_high_f','daily_low_f'].join(','));
      const mapHi=Object.fromEntries((last.dailyHi||[]).map(p=>[dateKeyLocal(p.x),p.y])); const mapLo=Object.fromEntries((last.dailyLo||[]).map(p=>[dateKeyLocal(p.x),p.y])); const keys=Array.from(new Set([...Object.keys(mapHi),...Object.keys(mapLo)])).sort();
      for(const dk of keys){ lines.push([ dk, last.iso||'', (last.loc?.name||'') + (last.loc?.state ? ', ' + last.loc.state : ''), last.loc?.stateCode||'', last.loc?.lat?.toFixed?.(4)||'', last.loc?.lon?.toFixed?.(4)||'', mapHi[dk]??'', mapLo[dk]??'' ].join(',')); }
    }
    return lines.join('\n');
  }

  function triggerDownloadCSV(){ if(!lastData) return; const csv=makeCSV(lastData); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const ts=new Date(); const stamp=`${ts.getFullYear()}${String(ts.getMonth()+1).padStart(2,'0')}${String(ts.getDate()).padStart(2,'0')}_${String(ts.getHours()).padStart(2,'0')}${String(ts.getMinutes()).padStart(2,'0')}`; const fname=`iso_forecast_${(lastData.iso||'ISO')}_${(lastData.loc?.stateCode||'US')}_${stamp}.csv`; const a=document.createElement('a'); a.href=url; a.download=fname; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }

  // ======= App wiring =======
  let autoTimer=null; function startAutoRefresh(cb){ if(autoTimer) clearInterval(autoTimer); autoTimer=setInterval(cb, 3600000); }

  async function fetchWeatherDaily30(lat, lon){ const d = await fetchWeather30(lat, lon); return d; }

  async function fetchWeatherDaily(lat, lon){ return (await fetchWeather30(lat, lon)); }

  async function loadForQuery(q, { useGeoLoc=false } = {}){
    try{
      $('#badge-upd').textContent='Loading…'; $('#badge-src').textContent='Source: —'; $('#note').textContent='';
      let loc; const fallbackZip = (q && String(q).trim()) || $('#zip').value.trim() || '94102';
      if (useGeoLoc){
        try{
          const pos = await geoLocate({ enableHighAccuracy:false, maximumAge:60000, timeout:10000 });
          const j = await fetchJSONWithFallback(`https://geocoding-api.open-meteo.com/v1/reverse?latitude=${pos.coords.latitude}&longitude=${pos.coords.longitude}&language=en&format=json`);
          const r = j?.results?.[0] || {};
          loc = { name: r?.name||'Current location', state: r?.admin1||'', stateCode: stateNameToCode(r?.admin1||''), country: (r?.country_code||'US').toUpperCase(), lat: pos.coords.latitude, lon: pos.coords.longitude };
          // Populate nearest ZIP into the input box (best-effort)
          try{
            const guessedZip = await nearestZipFromCoords(loc.lat, loc.lon, r?.name||'', loc.stateCode);
            if (guessedZip) { document.getElementById('zip').value = guessedZip; setURLParam('zip', guessedZip); }
          }catch(_e){}
        }catch(geoErr){
          const msg = explainGeoError(geoErr);
          $('#note').textContent = msg + ' Falling back to ZIP ' + fallbackZip + '.';
          loc = await geocodeZipOrText(fallbackZip);
        }
      } else {
        loc = await geocodeZipOrText(fallbackZip);
      }

      const forcedIso = $('#isoSelect').value; const urlIso = new URLSearchParams(location.search).get('iso');
      const iso = (forcedIso && forcedIso!=='auto') ? forcedIso : (urlIso || stateToISO(loc.stateCode));

      $('#badge-iso').textContent = `ISO: ${iso}`;
      $('#where').innerHTML = '<span class="dot ok"></span> <strong>' + loc.name + '</strong>' + (loc.state ? ', ' + loc.state : '') + ' — ' + loc.country + ' · (' + loc.lat.toFixed(3) + ', ' + loc.lon.toFixed(3) + ')';

      const [weather, load] = await Promise.allSettled([ fetchWeatherDaily30(loc.lat, loc.lon), fetchLoadForecastForISO(iso) ]);
      const daily = weather.status==='fulfilled' ? weather.value : null; const { outHi, outLo } = daily ? prepareDailyTemps(daily, 30) : { outHi:[], outLo:[] };

      let loadPts = (load.status==='fulfilled' ? load.value.points : []) || []; const sourceTxt = (load.status==='fulfilled' ? load.value.source : 'Load source unavailable');
      loadPts = limitToHorizon(loadPts, 30); const peaks = computeDailyPeaks(loadPts);

      // Build projection beyond last actual peak day
      const { series: projSeries } = projectFromTemps(outHi, outLo, peaks);
      const lastActualTime = loadPts.length ? loadPts[loadPts.length-1].x : null;
      const projFiltered = projSeries.filter(p => !lastActualTime || p.x > lastActualTime);

      const ctx = document.getElementById('chart').getContext('2d'); buildChart(ctx, loadPts, projFiltered, outHi, outLo, peaks);
      lastData = { load: loadPts, proj: projFiltered, dailyHi: outHi, dailyLo: outLo, peaks, iso, loc };

      $('#badge-src').textContent = `Source: ${sourceTxt}`; $('#badge-upd').textContent = `Last update: ${fmt.format(new Date())}`;
      if (!loadPts.length) $('#note').textContent = ($('#note').textContent ? $('#note').textContent + ' ' : '') + 'Note: This ISO did not return a keyless multi‑day hourly load forecast. Showing weather + projected load only (if model fit succeeded).';

      startAutoRefresh(()=> loadForQuery(fallbackZip, { useGeoLoc }));
    }catch(err){ console.error(err); $('#where').innerHTML = `<span class="dot err"></span> ${err?.message||err}`; $('#badge-upd').textContent='Error'; }
  }

  // UI
  $('#go').addEventListener('click', ()=>{ const zip=$('#zip').value.trim(); if(!zip) return; loadForQuery(zip); });
  $('#zip').addEventListener('keydown', (e)=>{ if(e.key==='Enter') $('#go').click(); });
  $('#loc').addEventListener('click', ()=> loadForQuery($('#zip').value.trim() || '94102', { useGeoLoc:true }));
  $('#isoSelect').addEventListener('change', ()=>{ const zip=$('#zip').value.trim(); loadForQuery(zip||'94102'); });
  $('#dlcsv').addEventListener('click', triggerDownloadCSV);
  function applyCompact(on){ document.body.classList.toggle('compact', !!on); }
  try { applyCompact(localStorage.getItem('compact')==='1'); } catch{}
  $('#compact').addEventListener('click', ()=>{ const on=!document.body.classList.contains('compact'); applyCompact(on); try{ localStorage.setItem('compact', on?'1':'0'); }catch{} });

  // Self‑tests (pure functions only)
  function runSelfTests(){
    const out = [];
    try { const s = dateKeyLocal(new Date('2025-01-02T03:04:05Z')); console.assert(/^2025-/.test(s), 'dateKeyLocal'); out.push('✓ dateKeyLocal'); } catch { out.push('✗ dateKeyLocal'); }
    try { const txt = 'Date,HE,MW\n2025-01-01,1,100\n2025-01-01,2,200'; const pts = parseCAISOCsv(txt); console.assert(Array.isArray(pts) && pts.length === 2 && pts[1].y === 200, 'parseCAISOCsv'); out.push('✓ parseCAISOCsv'); } catch { out.push('✗ parseCAISOCsv'); }
    try { const d=new Date('2025-03-04T06:00:00Z'); console.assert(/\/2025\/03\/04\/OP-MTLF-2025030406/.test(formatSPPPath(d)), 'formatSPPPath'); out.push('✓ formatSPPPath'); } catch { out.push('✗ formatSPPPath'); }
    try { const daily={ time:Array.from({length:30},(_,i)=>`2025-01-${String(i+1).padStart(2,'0')}`), temperature_2m_max:Array.from({length:30},(_,i)=>i), temperature_2m_min:Array.from({length:30},(_,i)=>-i) }; const r=prepareDailyTemps(daily,30); console.assert(r.outHi.length===30 && r.outLo.length===30, 'prepareDailyTemps -> 30 days'); out.push('✓ prepareDailyTemps(30)'); } catch { out.push('✗ prepareDailyTemps(30)'); }
    try { const coeff=fitLinear([60,70,80,90],[20,40,60,80]); console.assert(Math.abs(coeff.a - (-100))<1e-6 && Math.abs(coeff.b-2) < 1e-6, 'fitLinear'); out.push('✓ fitLinear'); } catch { out.push('✗ fitLinear'); }
    try { console.assert(defaultShape().reduce((m,v)=>Math.max(m,v),0) === 1, 'defaultShape normalized'); out.push('✓ defaultShape'); } catch { out.push('✗ defaultShape'); }
    try { const dkm=haversineKm(0,0,0,1); console.assert(dkm>100 && dkm<130, 'haversineKm'); out.push('✓ haversineKm'); } catch { out.push('✗ haversineKm'); }
    try { console.assert(stateToISO('CA')==='CAISO', 'stateToISO'); out.push('✓ stateToISO'); } catch { out.push('✗ stateToISO'); }
    try { const msg = explainGeoError({code:1}); console.assert(/permission/i.test(msg.toLowerCase()), 'explainGeoError'); out.push('✓ explainGeoError'); } catch { out.push('✗ explainGeoError'); }
    const div = document.querySelector('#testout'); if (div) div.textContent = out.join(' · ');
  }
  document.getElementById('runtests')?.addEventListener('click', runSelfTests);

  // Boot
  window.addEventListener('load', ()=>{ const p=new URLSearchParams(location.search); const urlZip=p.get('zip'); const urlIso=p.get('iso'); if(urlIso) $('#isoSelect').value=urlIso; if(urlZip){ $('#zip').value=urlZip; loadForQuery(urlZip); } else { $('#zip').value='94102'; loadForQuery('94102'); } });
  </script>
</body>
</html>
