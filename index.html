<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>30 Day Weather & Grid Forecast</title>
<meta name="description" content="ISO: hourly-only EIA v2; 24–48h from latest rows (future-only) with Region→Sub-BA fallbacks; 30d = same-date averages of DAILY PEAKS from ~3y hourly demand. Optional renewables/fossil daily peaks. Weather: forecast → 3y averages. Crosshair hover; callouts for Today & Tomorrow. Auto-ISO from ZIP (overrides)." />
<style>
  :root{--bg:#0b0f17;--fg:#e8ecf3;--muted:#9aa7b1;--card:#111726}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #1e2535;flex-wrap:wrap}
  h1{font-size:1rem;margin:0}
  .meta{color:var(--muted);font-size:.9rem}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  select,input,button{background:#0e1524;color:var(--fg);border:1px solid #20304b;border-radius:10px;padding:6px 10px}
  button{cursor:pointer}
  main{padding:12px}
  .grid{display:grid;gap:12px}
  @media(min-width:1100px){.grid{grid-template-columns:1fr 1fr}}
  .card{background:var(--card);border:1px solid #1b2334;border-radius:14px;padding:12px}
  .title{font-weight:600;margin:0 0 6px 0}
  .sub{color:var(--muted);margin:6px 0 0 0}
  #statusLoad,#statusWx{font-size:.9rem;color:var(--muted);margin-top:6px;min-height:1.2em;white-space:pre-wrap}
  .card canvas{width:100%;height:500px!important;max-height:500px;display:block}
  .peaks{margin-top:6px;font-size:.95rem}
  .peaks span{display:block;margin:4px 0}
</style>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
<header>
  <div>
    <h1>30 Day Weather & Grid Forecast</h1>
    <div class="meta">
      ISO: 24–48h via EIA v2 hourly (future-only; Region→Sub-BA fallbacks). 30-day = same-date averages of DAILY PEAKS from ~3y hourly demand. Optional renewables & fossil daily peaks (if available). Weather: forecast → 3-year averages.
    </div>
  </div>
  <div class="controls">
    <label>ISO
      <select id="isoSelect">
        <option value="CISO">CAISO</option><option value="PJM">PJM</option>
        <option value="MISO">MISO</option><option value="SPP">SPP</option>
        <option value="ISNE">ISO-NE</option><option value="NYIS">NYISO</option>
        <option value="ERCO">ERCOT</option>
      </select>
    </label>
    <label>ZIP
      <input id="zipInput" type="text" inputmode="numeric" pattern="[0-9]{5}" placeholder="e.g., 90012" value="90012" />
    </label>
    <label style="display:inline-flex;gap:6px;align-items:center;font-size:.9rem;color:#9aa7b1">
      <input id="autoIsoToggle" type="checkbox" checked /> Auto-ISO from ZIP
    </label>
    <button id="runBtn" type="button">Run</button>
  </div>
</header>

<main>
  <div class="grid">
    <div class="card">
      <p class="title">ISO Load — 30-Day Forecast</p>
      <p class="sub">Green: ISO daily peak (same-date avg of past ~3y hourly D; day 1 = today’s predicted peak). Orange: renewables daily peak (if available). Brown: fossil daily peak (if available).</p>
      <canvas id="loadChart" aria-label="ISO Load Chart"></canvas>
      <div id="statusLoad">Ready.</div>
      <div class="peaks" id="peakIso">
        <span>Today's Predicted Peak Hour (ISO): —</span>
        <span>Tomorrow's Forecast Peak Hour (ISO): —</span>
      </div>
    </div>
    <div class="card">
      <p class="title">Weather — 30-Day Daily High/Low</p>
      <p class="sub">High (red), Low (blue). Days 1–16: forecast • Days 17–30: 3-year same-date averages</p>
      <canvas id="wxChart" aria-label="Weather Chart"></canvas>
      <div id="statusWx">Ready.</div>
      <div class="peaks" id="peakWx">
        <span>Today's Predicted Peak Hour (Temp): —</span>
        <span>Tomorrow's Forecast Peak Hour (Temp): —</span>
      </div>
    </div>
  </div>
</main>

<script>
/* ===== Config ===== */
const DISPLAY_TZ = "America/Phoenix"; // used for “today/tomorrow” windows
const EIA_BASE   = "https://api.eia.gov/v2";
const EIA_KEY    = "DDtDBwdrxbGSSPNQBFP2JWvWDfSxTeVzg7qFWBfI";
const OVERRIDES_URL = "iso-overrides.json";

const FUEL_RENEW  = ["SUN","SOLAR","WAT","HYD","WND","WIND","GEO","OTHW","BIO","BM","HPS"];
const FUEL_FOSSIL = ["COL","COAL","NG","NATGAS","OIL","PET","LIG","RC","WOC"];

/* ===== Utils ===== */
const sleep = ms => new Promise(r=>setTimeout(r,ms));
function pad(n){return String(n).padStart(2,"0")}
function toDateStrLocal(d){return d.getFullYear()+"-"+pad(d.getMonth()+1)+"-"+pad(d.getDate())}
function fromDateStr(s){const [y,m,dd]=s.split("-").map(n=>parseInt(n,10)); return new Date(y,m-1,dd)}
function fmtHour(tsMs,tz){return new Intl.DateTimeFormat('en-US',{hour:'2-digit',minute:'2-digit',hour12:false,timeZone:tz}).format(new Date(tsMs))}
function fmtDay(tsMs,tz){return new Intl.DateTimeFormat('en-US',{year:'numeric',month:'2-digit',day:'2-digit',timeZone:tz}).format(new Date(tsMs))}

/* Local-day window helpers in arbitrary TZ */
function startOfLocalDay(ts, tz, addDays=0){
  // ts is a ms timestamp (e.g., Date.now())
  const d = new Date(ts);
  const parts = new Intl.DateTimeFormat('en-CA',{timeZone:tz,year:'numeric',month:'2-digit',day:'2-digit'}).formatToParts(d);
  const y = +parts.find(p=>p.type==='year').value;
  const m = +parts.find(p=>p.type==='month').value;
  const da= +parts.find(p=>p.type==='day').value;
  const base = new Date(Date.UTC(y, m-1, da, 0,0,0));
  base.setUTCDate(base.getUTCDate()+addDays);
  return base.getTime();
}
function endOfLocalDay(ts, tz, addDays=0){
  return startOfLocalDay(ts, tz, addDays+1)-1;
}

/* ===== Error surfacing ===== */
addEventListener('error', e=>{
  const msg = e.message || String(e.error||'error');
  const sL = document.getElementById('statusLoad'), sW = document.getElementById('statusWx');
  if (sL) sL.textContent += "\nJS error: "+msg;
  if (sW) sW.textContent += "\nJS error: "+msg;
});
addEventListener('unhandledrejection', e=>{
  const msg = (e && e.reason && (e.reason.message || String(e.reason))) || 'unhandled promise rejection';
  const sL = document.getElementById('statusLoad'), sW = document.getElementById('statusWx');
  if (sL) sL.textContent += "\nPromise error: "+msg;
  if (sW) sW.textContent += "\nPromise error: "+msg;
});

/* ===== HTTP with retries ===== */
async function fetchJson(url, tries=3, timeoutMs=16000){
  let lastErr;
  for (let i=0;i<tries;i++){
    const ctrl = new AbortController(); const to = setTimeout(()=>ctrl.abort(), timeoutMs);
    try{
      const r = await fetch(url, {signal: ctrl.signal, cache:'no-store'});
      if (r.ok){ clearTimeout(to); return await r.json(); }
      const txt = await r.text().catch(()=>r.statusText);
      lastErr = new Error("HTTP "+r.status+" — "+txt);
      clearTimeout(to);
      if (r.status===429 || (r.status>=500 && r.status<600)) { await sleep(400*(i+1)*(i+1)); continue; }
      throw lastErr;
    }catch(e){ lastErr=e; clearTimeout(to); if (i===tries-1) throw e; await sleep(400*(i+1)*(i+1)); }
  }
  throw lastErr || new Error("fetch failed");
}

/* ===== EIA v2 (hourly only; no start/end) ===== */
function eiaUrl(path, params){
  const u = new URL(EIA_BASE + "/" + path + "/data/");
  const p = new URLSearchParams();
  p.set("api_key", EIA_KEY);
  p.set("frequency", params.frequency || "hourly");
  p.set("sort[0][column]", params.sortCol || "period");
  p.set("sort[0][direction]", params.sortDir || "desc");
  p.set("offset", String(params.offset ?? 0));
  p.set("length", String(params.length ?? 5000));
  p.append("data[]","value");
  if (params.facets){
    for (const [k,v] of Object.entries(params.facets)){
      const arr = Array.isArray(v) ? v : [v];
      for (const item of arr) p.append(`facets[${k}][]`, item);
    }
  }
  u.search = p.toString();
  return u.toString();
}

async function eiaPagedLatest(path, facets, desiredRows, frequency="hourly"){
  let out=[], offset=0;
  while (out.length < desiredRows){
    const url = eiaUrl(path, {facets, frequency, sortCol:"period", sortDir:"desc", offset, length:5000});
    const j = await fetchJson(url);
    const rows = j?.response?.data || [];
    if (!rows.length) break;
    out = out.concat(rows);
    offset += rows.length;
    if (rows.length < 5000) break;
  }
  out.sort((a,b)=> Date.parse(a.period) - Date.parse(b.period));
  return out;
}

function rowsToSeries(rows){
  const out=[];
  for (const r of rows){
    const v = Number(r.value);
    const ts = Date.parse(r.period);
    if (isFinite(v) && isFinite(ts)) out.push({ts, val:v});
  }
  return out;
}

/* Region/Sub-BA latest */
async function latestRegionHours(respondent, type, N=96){
  const rows = await eiaPagedLatest("electricity/rto/region-data",
    { type, respondent }, N, "hourly");
  return rowsToSeries(rows);
}
async function latestSubBAHours(respondent, type, N=96){
  const rows = await eiaPagedLatest("electricity/rto/region-sub-ba-data",
    { type, parent: respondent }, N, "hourly");
  const byTs = new Map();
  for (const r of rows){
    const v = Number(r.value), ts = Date.parse(r.period);
    if(!isFinite(v)||!isFinite(ts)) continue;
    byTs.set(ts, (byTs.get(ts)||0)+v);
  }
  return Array.from(byTs.entries()).sort((a,b)=>a[0]-b[0]).map(([ts,val])=>({ts,val}));
}

/* Get 0–48h FUTURE forecast hours (now → now+48h), preferring DF */
async function eiaFuture0to48(respondent){
  const now = Date.now(), cutoff = now + 48*3600*1000;
  function futureOnly(arr){ return arr.filter(p => p.ts >= now && p.ts <= cutoff); }

  try{ const d = futureOnly(await latestRegionHours(respondent,"DF",192)); if(d.length) return {data:d, src:"EIA Region DF"}; }catch(e){}
  try{ const d = futureOnly(await latestRegionHours(respondent,"D", 192)); if(d.length) return {data:d, src:"EIA Region D"}; }catch(e){}
  try{ const d = futureOnly(await latestSubBAHours(respondent,"DF",192)); if(d.length) return {data:d, src:"EIA Sub-BA DF (sum)"}; }catch(e){}
  try{ const d = futureOnly(await latestSubBAHours(respondent,"D", 192)); if(d.length) return {data:d, src:"EIA Sub-BA D (sum)"}; }catch(e){}
  return {data:[], src:"unavailable"};
}

/* ==== Build ~3.5y hourly D → DAILY PEAKS ==== */
async function eiaHourlyD_dailyPeaks_3y(respondent){
  const approxHours = 90000;
  const rows = await eiaPagedLatest("electricity/rto/region-data",
    { type:"D", respondent }, approxHours, "hourly");
  const byDate = new Map();
  for (const r of rows){
    const d = r.period.slice(0,10);
    const v = Number(r.value);
    if (!isFinite(v)) continue;
    const cur = byDate.get(d);
    if (cur==null || v>cur) byDate.set(d, v);
  }
  return byDate;
}

/* ==== Optional: fuel mix → daily peak (renew/fossil) ==== */
async function eiaFuel_dailyPeaks_3y(respondent){
  const approxHours = 90000;
  let rows=[];
  try{
    rows = await eiaPagedLatest("electricity/rto/region-fuel-type-data",
      { parent: respondent }, approxHours, "hourly");
  }catch(_){}
  if (!rows.length){
    try{
      rows = await eiaPagedLatest("electricity/rto/fuel-type-data",
        { respondent }, approxHours, "hourly");
    }catch(_){}
  }
  if (!rows.length) return {renew:null, fossil:null, note:"Fuel-type hourly data not available for this ISO."};

  const hourRenew = new Map(), hourFossil = new Map(); // YYYY-MM-DDTHH -> MW
  for (const r of rows){
    const ts = Date.parse(r.period);
    if (!isFinite(ts)) continue;
    const v = Number(r.value); if (!isFinite(v)) continue;
    const fuel = (r.fueltype || r.fuel_type || r.type || "").toUpperCase();
    const key = new Date(ts).toISOString().slice(0,13);
    if (FUEL_RENEW.includes(fuel))  hourRenew.set(key,  (hourRenew.get(key)||0)  + v);
    if (FUEL_FOSSIL.includes(fuel)) hourFossil.set(key, (hourFossil.get(key)||0) + v);
  }
  const renewDaily = new Map(), fossilDaily = new Map();
  for (const [h, val] of hourRenew){  const d=h.slice(0,10); renewDaily.set(d,  Math.max(val, renewDaily.get(d)||0)); }
  for (const [h, val] of hourFossil){ const d=h.slice(0,10); fossilDaily.set(d, Math.max(val, fossilDaily.get(d)||0)); }
  return {renew: renewDaily, fossil: fossilDaily, note:null};
}

/* ===== Same-date averaging ===== */
function sameDateAvg(mapByDate, targetDateStr){
  const dt = fromDateStr(targetDateStr);
  const vals = [];
  for (let back=1; back<=3; back++){
    const d = new Date(dt); d.setFullYear(d.getFullYear()-back);
    const key = toDateStrLocal(d);
    const v = mapByDate.get(key);
    if (isFinite(v)) vals.push(v);
  }
  if (!vals.length) return null;
  return vals.reduce((a,b)=>a+b,0)/vals.length;
}

/* ===== Weather (Open-Meteo) & ZIP ===== */
async function zipToLatLon(zip){
  const j = await fetchJson("https://api.zippopotam.us/us/"+zip);
  const p=j?.places?.[0]; if(!p) throw new Error("ZIP not found");
  return {lat:parseFloat(p.latitude), lon:parseFloat(p.longitude), state:p['state abbreviation']};
}
async function getDailyForecast(lat, lon){
  const url = "https://api.open-meteo.com/v1/forecast?latitude="+lat+"&longitude="+lon+"&daily=temperature_2m_max,temperature_2m_min&forecast_days=16&temperature_unit=fahrenheit&timezone=auto";
  const j=await fetchJson(url); const d=j?.daily; if(!d||!d.time) return [];
  const out=[]; for(let i=0;i<d.time.length;i++){
    const day=d.time[i]; const tmax=Number(d.temperature_2m_max[i]); const tmin=Number(d.temperature_2m_min[i]);
    if(isFinite(tmax)&&isFinite(tmin)) out.push({date:day,tmax,tmin});
  }
  return out;
}
async function getArchiveDaily(lat, lon, startStr, endStr){
  const url = "https://archive-api.open-meteo.com/v1/archive?latitude="+lat+"&longitude="+lon+"&start_date="+startStr+"&end_date="+endStr+"&daily=temperature_2m_max,temperature_2m_min&temperature_unit=fahrenheit&timezone=auto";
  const j=await fetchJson(url); const d=j?.daily; if(!d||!d.time) return [];
  const out=[]; for(let i=0;i<d.time.length;i++){
    const day=d.time[i]; const tmax=Number(d.temperature_2m_max[i]); const tmin=Number(d.temperature_2m_min[i]);
    if(isFinite(tmax)&&isFinite(tmin)) out.push({date:day,tmax,tmin});
  }
  return out;
}
async function getHourlyTemps(lat, lon, hours=48){
  const days = Math.ceil((hours+1)/24);
  const url = "https://api.open-meteo.com/v1/forecast?latitude="+lat+"&longitude="+lon+"&hourly=temperature_2m&forecast_days="+days+"&timeformat=unixtime&temperature_unit=fahrenheit&timezone=auto";
  const j=await fetchJson(url); const h=j?.hourly; if(!h||!h.time) return [];
  const now = Date.now(), cutoff = now + hours*3600*1000, out=[];
  for(let i=0;i<h.time.length;i++){
    const ts = Number(h.time[i])*1000; if(ts < now || ts > cutoff) continue;
    const t = Number(h.temperature_2m[i]); if(isFinite(t)) out.push({ts, t});
  }
  out.sort((a,b)=>a.ts-b.ts); return out;
}

/* ===== Day-bounded peak finders (local TZ) ===== */
function maxInWindow(hours, startMs, endMs){
  let m = -Infinity, ts = null;
  for (const p of hours){
    if (p.ts >= startMs && p.ts <= endMs && p.val > m){ m = p.val; ts = p.ts; }
  }
  return (ts==null) ? null : { ts, val:m };
}
function maxTempInWindow(hours, startMs, endMs){
  let m = -Infinity, ts = null;
  for (const p of hours){
    if (p.ts >= startMs && p.ts <= endMs && p.t > m){ m = p.t; ts = p.ts; }
  }
  return (ts==null) ? null : { ts, val:m };
}

/* ===== Overrides (ZIP→ISO) ===== */
let EXT_OVERRIDES = { zip5:[], zip3:[] };
function parseRangesContains(zip, ranges){
  const target = parseInt(zip,10);
  for (const r of ranges){
    if (!r) continue;
    if (r.includes("-")){
      const [a,b] = r.split("-").map(x=>parseInt(x,10));
      if (target>=a && target<=b) return true;
    } else if (parseInt(r,10) === target){ return true; }
  }
  return false;
}
async function loadOverrides(){
  try{
    const j = await fetchJson(OVERRIDES_URL+"?_="+Date.now());
    EXT_OVERRIDES.zip5 = Array.isArray(j.zip5)? j.zip5 : [];
    EXT_OVERRIDES.zip3 = Array.isArray(j.zip3)? j.zip3 : [];
  }catch(e){
    console.warn("iso-overrides.json not loaded:", e.message||e);
    EXT_OVERRIDES = { zip5:[], zip3:[] };
  }
}
function zip3Of(zip){ return zip.slice(0,3); }
function chooseISOWithOverrides(zip, state, currentISO){
  const z5 = zip, z3 = zip3Of(zip);
  for (const rule of EXT_OVERRIDES.zip5){ if (parseRangesContains(z5, rule.ranges)) return { iso: rule.iso, reason: `zip5 override (${z5})` }; }
  for (const rule of EXT_OVERRIDES.zip3){ if (parseRangesContains(z3, rule.ranges)) return { iso: rule.iso, reason: `zip3 override (${z3})` }; }
  return { iso: currentISO, reason: "no mapping — keeping selection" };
}

/* ===== Crosshair plugin ===== */
const crosshairPlugin = {
  id: 'crosshair',
  afterDraw(chart) {
    const {ctx, tooltip, chartArea:{top,bottom}} = chart;
    const active = tooltip?.getActiveElements?.() || [];
    if (!active.length) return;
    const x = active[0].element.x;
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x, top);
    ctx.lineTo(x, bottom);
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.stroke();
    ctx.restore();
  }
};

/* ===== Charts ===== */
let loadChart, wxChart, RENDER_TOKEN=0;
function initCharts(){
  Chart.register(crosshairPlugin);
  if (!loadChart){
    loadChart = new Chart(document.getElementById("loadChart").getContext("2d"),{
      type:"line",
      data:{labels:[], datasets:[
        {label:"ISO Daily Peak (MW)", data:[], borderWidth:2, pointRadius:0, borderColor:"#22c55e"}, /* green */
        {label:"Renewables Daily Peak (MW)", data:[], borderWidth:2, pointRadius:0, borderColor:"#f59e0b"}, /* orange */
        {label:"Fossil Daily Peak (MW)", data:[], borderWidth:2, pointRadius:0, borderColor:"#a16207"} /* brown */
      ]},
      options:{
        responsive:true, maintainAspectRatio:false,
        interaction:{ mode:'index', intersect:false, axis:'x' },
        plugins:{ legend:{ labels:{ color:"#dbe6f2", usePointStyle:true } }, tooltip:{ enabled:true } },
        scales:{
          x:{ type:"category", ticks:{ color:"#b8c2cc", maxRotation:0, autoSkip:true, autoSkipPadding:8 }, grid:{ color:"rgba(255,255,255,0.06)" } },
          y:{ ticks:{ color:"#b8c2cc" }, grid:{ color:"rgba(255,255,255,0.06)" } }
        }
      }
    });
  }
  if (!wxChart){
    wxChart = new Chart(document.getElementById("wxChart").getContext("2d"),{
      type:"line",
      data:{labels:[], datasets:[
        {label:"Daily High (°F)", data:[], borderWidth:2, pointRadius:0, borderColor:"#ef4444"}, /* red */
        {label:"Daily Low (°F)",  data:[], borderWidth:2, pointRadius:0, borderColor:"#3b82f6"}  /* blue */
      ]},
      options:{
        responsive:true, maintainAspectRatio:false,
        interaction:{ mode:'index', intersect:false, axis:'x' },
        plugins:{ legend:{ labels:{ color:"#dbe6f2", usePointStyle:true } }, tooltip:{ enabled:true } },
        scales:{
          x:{ type:"category", ticks:{ color:"#b8c2cc", maxRotation:0, autoSkip:true, autoSkipPadding:8 }, grid:{ color:"rgba(255,255,255,0.06)" } },
          y:{ ticks:{ color:"#b8c2cc" }, grid:{ color:"rgba(255,255,255,0.06)" } }
        }
      }
    });
  }
}

/* ===== Builders ===== */
function next30DayLabels(){
  const today = new Date(); today.setHours(0,0,0,0);
  const labels=[]; for(let i=0;i<30;i++){ const d=new Date(today); d.setDate(today.getDate()+i); labels.push(toDateStrLocal(d)); }
  return labels;
}

async function buildISO(respondent, zip){
  const labels = next30DayLabels();

  // Future-only forecast hours
  let hours=[], src="unavailable", eiaErr=null;
  try{ const got = await eiaFuture0to48(respondent); hours = got.data; src = got.src; }
  catch(e){ eiaErr = e; }

  // 3y hourly D → DAILY PEAKS (climatology)
  let dailyPeakMap=null, climoPeak=[];
  try{
    dailyPeakMap = await eiaHourlyD_dailyPeaks_3y(respondent);
    climoPeak = labels.map(date => ({ date, val: sameDateAvg(dailyPeakMap, date) }));
  }catch(e){ climoPeak = labels.map(d=>({date:d, val:null})); eiaErr = eiaErr||e; }

  // Optional fuel-type peaks
  let renewSeries=null, fossilSeries=null, fuelNote=null;
  try{
    const fp = await eiaFuel_dailyPeaks_3y(respondent);
    fuelNote = fp.note;
    if (fp.renew)  renewSeries  = labels.map(date => ({date, val: sameDateAvg(fp.renew,  date)}));
    if (fp.fossil) fossilSeries = labels.map(date => ({date, val: sameDateAvg(fp.fossil, date)}));
  }catch(e){ fuelNote = (e && e.message) ? e.message : "Fuel-type peaks unavailable."; }

  // Today & Tomorrow windows in DISPLAY_TZ
  const now = Date.now();
  const todayStart = startOfLocalDay(now, DISPLAY_TZ, 0);
  const todayEnd   = endOfLocalDay(now,   DISPLAY_TZ, 0);
  const tomorrowStart = startOfLocalDay(now, DISPLAY_TZ, 1);
  const tomorrowEnd   = endOfLocalDay(now,   DISPLAY_TZ, 1);

  // ISO peak callouts
  let peakToday = null, peakTomorrow = null;

  if (hours.length){
    peakToday    = maxInWindow(hours, todayStart, todayEnd);
    peakTomorrow = maxInWindow(hours, tomorrowStart, tomorrowEnd);
  }

  // If DF missing, synthesize from weather-based shape (fallback)
  if ((!peakToday || !peakTomorrow) && !hours.length){
    try{
      const {lat, lon} = await zipToLatLon(zip);
      const hourly48 = await getHourlyTemps(lat, lon, 48);
      if (hourly48.length){
        // baseline from climatology day 1 (or a guard)
        const base = climoPeak[0]?.val ?? 10000;
        const temps = hourly48.map(p=>p.t);
        const meanT = temps.reduce((a,b)=>a+b,0)/temps.length;
        const k = 0.02;
        const synth = hourly48.map(p=>({ts:p.ts, val: base * Math.max(0.6, 1 + k*(p.t - meanT))}));
        peakToday    = maxInWindow(synth, todayStart, todayEnd);
        peakTomorrow = maxInWindow(synth, tomorrowStart, tomorrowEnd);
        if (src === "unavailable") src = "weather-shaped";
      }
    }catch(_){}
  }

  // Overwrite day-1 (today) with predicted peak if available
  if (peakToday && climoPeak.length) climoPeak[0].val = peakToday.val;

  if (eiaErr)   document.getElementById("statusLoad").textContent += "\nEIA fetch note: "+(eiaErr.message||eiaErr);
  if (fuelNote) document.getElementById("statusLoad").textContent += "\nFuel note: "+fuelNote;

  return { labels, climoPeak, renewSeries, fossilSeries, src, peakToday, peakTomorrow, pointsFuture: hours.length };
}

async function buildWx(zip){
  const {lat, lon} = await zipToLatLon(zip);
  const today = new Date();
  const labels=[]; for(let i=0;i<30;i++){ const d=new Date(today); d.setDate(today.getDate()+i); labels.push(toDateStrLocal(d)); }
  const startStr = labels[0], endStr = labels[labels.length-1];

  // daily series
  let forecast=[]; try{ forecast = await getDailyForecast(lat, lon); }catch(e){}
  const fMap = new Map(forecast.map(d=>[d.date,d]));
  async function fetchYear(back){
    const s = fromDateStr(startStr); s.setFullYear(s.getFullYear()-back);
    const e = fromDateStr(endStr);   e.setFullYear(e.getFullYear()-back);
    const url = "https://archive-api.open-meteo.com/v1/archive?latitude="+lat+"&longitude="+lon+"&start_date="+toDateStrLocal(s)+"&end_date="+toDateStrLocal(e)+"&daily=temperature_2m_max,temperature_2m_min&temperature_unit=fahrenheit&timezone=auto";
    const j=await fetchJson(url); const d=j?.daily; if(!d||!d.time) return [];
    const out=[]; for(let i=0;i<d.time.length;i++){
      const day=d.time[i]; const tmax=Number(d.temperature_2m_max[i]); const tmin=Number(d.temperature_2m_min[i]);
      if(isFinite(tmax)&&isFinite(tmin)) out.push({date:day,tmax,tmin});
    }
    return out;
  }
  let y1=[],y2=[],y3=[]; try{ [y1,y2,y3]=await Promise.all([fetchYear(1),fetchYear(2),fetchYear(3)]);}catch(e){}
  const m1=new Map(y1.map(o=>[o.date,o])), m2=new Map(y2.map(o=>[o.date,o])), m3=new Map(y3.map(o=>[o.date,o]));

  const hi=[], lo=[]; let usedF=0, usedC=0;
  for(const d of labels){
    if (fMap.has(d)){ const v=fMap.get(d); hi.push(v.tmax); lo.push(v.tmin); usedF++; continue; }
    const dt = fromDateStr(d);
    const d1 = toDateStrLocal(new Date(dt.getFullYear()-1, dt.getMonth(), dt.getDate()));
    const d2 = toDateStrLocal(new Date(dt.getFullYear()-2, dt.getMonth(), dt.getDate()));
    const d3 = toDateStrLocal(new Date(dt.getFullYear()-3, dt.getMonth(), dt.getDate()));
    const maxs=[], mins=[];
    if(m1.has(d1)){ maxs.push(m1.get(d1).tmax); mins.push(m1.get(d1).tmin); }
    if(m2.has(d2)){ maxs.push(m2.get(d2).tmax); mins.push(m2.get(d2).tmin); }
    if(m3.has(d3)){ maxs.push(m3.get(d3).tmax); mins.push(m3.get(d3).tmin); }
    if(maxs.length){ hi.push(maxs.reduce((a,b)=>a+b,0)/maxs.length); lo.push(mins.reduce((a,b)=>a+b,0)/mins.length); usedC++; }
    else { hi.push(null); lo.push(null); }
  }

  // Hourly temps for today/tomorrow callouts
  let peakToday=null, peakTomorrow=null;
  try{
    const hourly48 = await getHourlyTemps(lat, lon, 48);
    const now = Date.now();
    const todayStart = startOfLocalDay(now, DISPLAY_TZ, 0);
    const todayEnd   = endOfLocalDay(now,   DISPLAY_TZ, 0);
    const tomorrowStart = startOfLocalDay(now, DISPLAY_TZ, 1);
    const tomorrowEnd   = endOfLocalDay(now,   DISPLAY_TZ, 1);
    peakToday    = maxTempInWindow(hourly48, todayStart, todayEnd);
    peakTomorrow = maxTempInWindow(hourly48, tomorrowStart, tomorrowEnd);
  }catch(e){}

  return { labels, hi, lo, usedF, usedC, peakToday, peakTomorrow };
}

/* ===== Render ===== */
let loadChart, wxChart;
let RENDER_TOKEN=0, firstRunDone=false;

function initChartsWrapper(){
  Chart.register(crosshairPlugin);
  if (!loadChart){
    loadChart = new Chart(document.getElementById("loadChart").getContext("2d"),{
      type:"line",
      data:{labels:[], datasets:[
        {label:"ISO Daily Peak (MW)", data:[], borderWidth:2, pointRadius:0, borderColor:"#22c55e"},
        {label:"Renewables Daily Peak (MW)", data:[], borderWidth:2, pointRadius:0, borderColor:"#f59e0b"},
        {label:"Fossil Daily Peak (MW)", data:[], borderWidth:2, pointRadius:0, borderColor:"#a16207"}
      ]},
      options:{
        responsive:true, maintainAspectRatio:false,
        interaction:{ mode:'index', intersect:false, axis:'x' },
        plugins:{ legend:{ labels:{ color:"#dbe6f2", usePointStyle:true } }, tooltip:{ enabled:true } },
        scales:{ x:{ type:"category", ticks:{ color:"#b8c2cc" }, grid:{ color:"rgba(255,255,255,0.06)" } },
                 y:{ ticks:{ color:"#b8c2cc" }, grid:{ color:"rgba(255,255,255,0.06)" } } }
      }
    });
  }
  if (!wxChart){
    wxChart = new Chart(document.getElementById("wxChart").getContext("2d"),{
      type:"line",
      data:{labels:[], datasets:[
        {label:"Daily High (°F)", data:[], borderWidth:2, pointRadius:0, borderColor:"#ef4444"},
        {label:"Daily Low (°F)",  data:[], borderWidth:2, pointRadius:0, borderColor:"#3b82f6"}
      ]},
      options:{
        responsive:true, maintainAspectRatio:false,
        interaction:{ mode:'index', intersect:false, axis:'x' },
        plugins:{ legend:{ labels:{ color:"#dbe6f2", usePointStyle:true } }, tooltip:{ enabled:true } },
        scales:{ x:{ type:"category", ticks:{ color:"#b8c2cc" }, grid:{ color:"rgba(255,255,255,0.06)" } },
                 y:{ ticks:{ color:"#b8c2cc" }, grid:{ color:"rgba(255,255,255,0.06)" } } }
      }
    });
  }
}

async function render(){
  const myToken = ++RENDER_TOKEN;
  initChartsWrapper();

  const isoSel = document.getElementById("isoSelect");
  const zipInp = document.getElementById("zipInput");
  const autoIso = document.getElementById("autoIsoToggle").checked;

  const zip = (zipInp.value||"").trim();
  const sL = document.getElementById("statusLoad");
  const sW = document.getElementById("statusWx");
  const pIso = document.getElementById("peakIso");
  const pWx  = document.getElementById("peakWx");

  // Need overrides before auto-ISO
  await loadOverrides();

  if (!/^[0-9]{5}$/.test(zip)){
    sW.textContent = "Enter a 5-digit ZIP to build weather.";
    sL.textContent = "Awaiting a valid ZIP to proceed.";
    return;
  }

  // Auto-ISO mapping
  try{
    const loc = await zipToLatLon(zip);
    if (myToken !== RENDER_TOKEN) return;
    if (autoIso){
      const { iso:suggested, reason } = chooseISOWithOverrides(zip, loc.state, isoSel.value);
      if (suggested && suggested !== "NONE" && isoSel.value !== suggested){
        const oldTxt = isoSel.options[isoSel.selectedIndex].text;
        isoSel.value = suggested;
        const newTxt = isoSel.options[isoSel.selectedIndex].text;
        sL.textContent = `Auto-ISO: ${oldTxt} → ${newTxt} (${reason}).`;
      } else {
        sL.textContent = `ISO unchanged (reason: ${reason}).`;
      }
    } else {
      sL.textContent = `Auto-ISO disabled. Using ${isoSel.options[isoSel.selectedIndex].text}.`;
    }
  }catch(e){
    if (myToken !== RENDER_TOKEN) return;
    sW.textContent = "ZIP lookup failed — " + (e.message||e);
    sL.textContent = "ZIP lookup failed — " + (e.message||e);
    return;
  }

  const iso = isoSel.value;

  /* WEATHER */
  sW.textContent = "Building weather (30d daily + Today/Tomorrow peaks)…";
  try{
    const wx = await buildWx(zip);
    if (myToken !== RENDER_TOKEN) return;
    wxChart.data.labels = wx.labels;
    wxChart.data.datasets[0].data = wx.hi;
    wxChart.data.datasets[1].data = wx.lo;
    wxChart.update();
    sW.textContent = `Weather built • forecast days: ${wx.usedF} • climatology days: ${wx.usedC} • range: ${wx.labels[0]} → ${wx.labels[wx.labels.length-1]}`;
    const lines = [];
    if (wx.peakToday){
      lines.push(`Today's Predicted Peak Hour (Temp): ${fmtDay(wx.peakToday.ts, DISPLAY_TZ)} @ ${fmtHour(wx.peakToday.ts, DISPLAY_TZ)} — ${Math.round(wx.peakToday.val)} °F`);
    } else {
      lines.push("Today's Predicted Peak Hour (Temp): unavailable.");
    }
    if (wx.peakTomorrow){
      lines.push(`Tomorrow's Forecast Peak Hour (Temp): ${fmtDay(wx.peakTomorrow.ts, DISPLAY_TZ)} @ ${fmtHour(wx.peakTomorrow.ts, DISPLAY_TZ)} — ${Math.round(wx.peakTomorrow.val)} °F`);
    } else {
      lines.push("Tomorrow's Forecast Peak Hour (Temp): unavailable.");
    }
    pWx.innerHTML = `<span>${lines[0]}</span><span>${lines[1]}</span>`;
  }catch(e){
    if (myToken !== RENDER_TOKEN) return;
    sW.textContent = "Error: Weather build failed — " + (e.message||e);
  }

  /* ISO */
  sL.textContent += (firstRunDone? "\n":"") + "Loading ISO (EIA v2 future-only) + building 29d peak climatology…";
  try{
    const { labels, climoPeak, renewSeries, fossilSeries, src, peakToday, peakTomorrow, pointsFuture } = await buildISO(iso, zip);
    if (myToken !== RENDER_TOKEN) return;

    loadChart.data.labels = labels;
    loadChart.data.datasets[0].data = climoPeak.map(d=>d.val);            // green
    loadChart.data.datasets[1].data = renewSeries ? renewSeries.map(d=>d.val) : []; // orange
    loadChart.data.datasets[2].data = fossilSeries ? fossilSeries.map(d=>d.val) : []; // brown
    loadChart.update();

    const ptsOk = climoPeak.map(d=>d.val).filter(v=>v!=null).length+"/"+labels.length;
    sL.textContent += `\nISO built • future source: ${pointsFuture?src:'weather-shaped'} • 30d points (daily peaks): ${ptsOk}`;

    const lines = [];
    if (peakToday){
      lines.push(`Today's Predicted Peak Hour (ISO): ${fmtDay(peakToday.ts, DISPLAY_TZ)} @ ${fmtHour(peakToday.ts, DISPLAY_TZ)} — ${Math.round(peakToday.val).toLocaleString()} MW`);
    } else {
      lines.push("Today's Predicted Peak Hour (ISO): unavailable.");
    }
    if (peakTomorrow){
      lines.push(`Tomorrow's Forecast Peak Hour (ISO): ${fmtDay(peakTomorrow.ts, DISPLAY_TZ)} @ ${fmtHour(peakTomorrow.ts, DISPLAY_TZ)} — ${Math.round(peakTomorrow.val).toLocaleString()} MW`);
    } else {
      lines.push("Tomorrow's Forecast Peak Hour (ISO): unavailable.");
    }
    document.getElementById("peakIso").innerHTML = `<span>${lines[0]}</span><span>${lines[1]}</span>`;
  }catch(e){
    if (myToken !== RENDER_TOKEN) return;
    sL.textContent += "\nError: ISO build failed — " + (e.message||e);
  }

  firstRunDone = true;
}

/* ===== Wire UI ===== */
(function wireUI(){
  const btn = document.getElementById("runBtn");
  const isoSel = document.getElementById("isoSelect");
  const zipInp = document.getElementById("zipInput");

  btn.addEventListener("click", render);
  isoSel.addEventListener("change", render);
  zipInp.addEventListener("keydown", e => { if (e.key === "Enter") { e.preventDefault(); render(); } });

  loadOverrides().finally(render);
})();
</script>
</body>
</html>
