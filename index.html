<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ISO Load + Weather — 10‑Day Forecast by ZIP</title>
  <meta name="description" content="Simple, keyless, GitHub‑Pages‑friendly site: enter a US ZIP, get a 10‑day ISO load forecast (area) + daily high/low temps (dotted)." />
  <style>
    :root{
      --bg:#0b1020; /* deep navy */
      --card:#121a33;
      --text:#eaf0ff;
      --muted:#9fb0d9;
      --accent:#4ea1ff;
      --danger:#ff4e4e;
      --ok:#66e;
      --grid:#1c274d;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:radial-gradient(1200px 800px at 15% -5%, #1a2447 0%, #0b1020 50%) fixed;color:var(--text)}
    header{padding:18px 16px;display:flex;gap:12px;align-items:center;flex-wrap:wrap;border-bottom:1px solid #111a33}
    h1{font-size:18px;margin:0;font-weight:700;letter-spacing:.2px}
    .sub{color:var(--muted);font-size:12px}
    .wrap{display:grid;gap:16px;padding:16px;max-width:1100px;margin:0 auto}
    .card{background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));border:1px solid #1a2447;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:14px}
    label{display:block;font-weight:600;margin:0 0 8px;color:#cfe0ff}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    input[type="text"]{appearance:none;background:#0f1731;border:1px solid #223061;color:var(--text);padding:12px 14px;border-radius:12px;min-width:220px;font-size:14px;outline:none}
    button{all:unset;display:inline-flex;align-items:center;gap:8px;background:linear-gradient(180deg,#4ea1ff,#2f78ff);color:white;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 6px 16px rgba(46,119,255,.35)}
    button.secondary{background:#0f1731;border:1px solid #223061;color:#bcd0ff;box-shadow:none}
    .hint{color:var(--muted);font-size:12px}
    .status{display:flex;align-items:center;gap:8px;color:#bcd0ff}
    .dot{width:8px;height:8px;border-radius:50%}
    .dot.ok{background:#5ee}
    .dot.warn{background:#ffa95e}
    .dot.err{background:#ff6868}
    canvas{width:100%;height:420px;background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));border-radius:12px;border:1px solid #1a2447}
    footer{color:#93a7d9;font-size:12px;display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    code,kbd{background:#0f1731;border:1px solid #223061;color:#bcd0ff;border-radius:6px;padding:0 6px}
    .badgelist{display:flex;flex-wrap:wrap;gap:8px}
    .badge{background:#0f1731;border:1px solid #223061;color:#bcd0ff;border-radius:100px;padding:4px 8px;font-size:12px}
    .sr-only{position:absolute;left:-9999px}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>ISO Load + Weather — 10‑Day Forecast</h1>
      <div class="sub">Keyless data sources. GitHub Pages friendly. Auto‑updates hourly.
      </div>
    </div>
  </header>

  <main class="wrap">
    <section class="card">
      <label for="zip">Enter a US ZIP code</label>
      <div class="row">
        <input id="zip" type="text" inputmode="numeric" pattern="\\d{5}" maxlength="10" placeholder="e.g., 94102" autocomplete="postal-code" />
        <button id="go">Get forecast</button>
        <button id="loc" class="secondary" title="Use your approximate location (browser prompt)">Use my location</button>
      </div>
      <div class="hint">Blue area = ISO load forecast (MW, left axis). Red dotted = daily high. Dark‑blue dotted = daily low (°F, right axis). Refreshes hourly.</div>
    </section>

    <section class="card">
      <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
        <div id="where" class="status">—</div>
        <div class="badgelist">
          <span class="badge" id="badge-iso">ISO: —</span>
          <span class="badge" id="badge-src">Source: —</span>
          <span class="badge" id="badge-upd">Last update: —</span>
        </div>
      </div>
      <canvas id="chart" aria-label="Load and temperature forecast" role="img"></canvas>
    </section>

    <section class="card">
      <details>
        <summary><strong>About & Data Sources</strong></summary>
        <p>• <strong>Load forecast</strong>: CAISO publishes a 10‑day hourly system load forecast via Today’s Outlook downloadable CSV; this page fetches those CSVs directly (with robust fallbacks) and plots them as a shaded area. For other ISOs, wire a source in <code>fetchLoadForecastForISO()</code>.</p>
        <p>• <strong>Weather</strong> (daily hi/lo): Open‑Meteo (<em>no key required</em>) via its <em>Geocoding API</em> (turns ZIP → lat/lon) and <em>Forecast API</em> for <code>temperature_2m_max</code> and <code>temperature_2m_min</code>.</p>
        <p class="hint">Client‑side only, designed for GitHub Pages. If an ISO CSV blocks CORS, this page falls back to a safe proxy (<code>api.allorigins.win</code>) to read public files.</p>
      </details>
    </section>

    <footer class="card">
      <div>Credits: CAISO “Today’s Outlook” CSVs; Open‑Meteo Geocoding + Weather APIs.</div>
      <div>Made for static hosting — no API keys, no server.</div>
    </footer>
  </main>

  <!-- Libraries (no-build, CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
  // ======= Small util helpers =======
  const $ = sel => document.querySelector(sel);
  const fmt = new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' });
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

  // Open‑Meteo endpoints (no key):
  const GEOCODE = name => `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(name)}&count=1&language=en&format=json&country=US`;
  const WEATHER = (lat, lon) => `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=temperature_2m_max,temperature_2m_min&temperature_unit=fahrenheit&timezone=auto&forecast_days=16`;

  // CAISO public CSV endpoints (ten‑day load forecast). We try multiple known paths + CORS fallbacks.
  const CAISO_CSV_URLS = [
    // Direct endpoints (first preference)
    'https://www.caiso.com/outlook/SP/Load/LoadForecast.csv',
    'https://content.caiso.com/outlook/SP/Load/LoadForecast.csv',
    // Case variants some mirrors use
    'https://www.caiso.com/outlook/SP/Load/loadforecast.csv',
    'https://content.caiso.com/outlook/SP/Load/loadforecast.csv',
  ];
  const withCORSProxy = (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;

  // Detect ISO by US state (lightweight mapping). For v1 we only wire CAISO.
  const stateToISO = (stateCode) => {
    if (stateCode === 'CA') return 'CAISO';
    if (stateCode === 'TX') return 'ERCOT';
    // Future: NY -> NYISO; CT/MA/ME/NH/RI/VT -> ISO-NE; many states -> PJM/MISO/SPP, etc.
    return 'UNKNOWN';
  };

  // Parse CAISO LoadForecast.csv into [{x: Date, y: MW}, ...]
  function parseCAISOCsv(text) {
    const parsed = Papa.parse(text.trim(), { header: true });
    if (!parsed.data || !parsed.data.length) throw new Error('Empty CSV');
    const rows = parsed.data;
    // Try to discover time & value columns
    const headers = parsed.meta.fields.map(h => h.trim());
    // possible time column names
    const timeKey = headers.find(h => /time|timestamp|datetime/i.test(h))
                 || (headers.includes('Date') && headers.includes('HE') ? 'Date' : null);
    // possible load column names
    const mwKey = headers.find(h => /mw|forecast|load/i.test(h) && !/net|price|temp|solar|wind/i.test(h));
    if (!mwKey) throw new Error('Could not find MW/forecast column in CSV headers: ' + headers.join(', '));

    const out = [];
    for (const r of rows) {
      if (!r) continue;
      let t = null;
      if (timeKey === 'Date' && r.Date && r.HE) {
        // If data is in Date + Hour Ending (HE 1..24) form, assume CAISO local time (PT)
        // Build ISO string as local date + (HE-1):00
        const he = Number(r.HE);
        if (!Number.isFinite(he)) continue;
        const d = new Date(r.Date);
        if (isNaN(d.getTime())) continue;
        d.setHours(he - 1, 0, 0, 0);
        t = d;
      } else if (timeKey && r[timeKey]) {
        const cand = new Date(r[timeKey]);
        if (!isNaN(cand)) t = cand;
      } else {
        // Some files may have an implicit sequence; skip if time missing
        continue;
      }
      const y = Number(String(r[mwKey]).replace(/[,\s]/g, ''));
      if (Number.isFinite(y) && t) out.push({ x: t, y });
    }
    // Sort by time
    out.sort((a, b) => a.x - b.x);
    return out;
  }

  async function fetchTextWithFallbacks(urls) {
    const errors = [];
    for (const url of urls) {
      // Try direct first
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (res.ok) return await res.text();
        errors.push(`${url} → HTTP ${res.status}`);
      } catch (e) {
        errors.push(`${url} → ${e?.message || e}`);
      }
      // Try proxy (CORS‑safe raw)
      try {
        const prox = withCORSProxy(url);
        const res2 = await fetch(prox, { cache: 'no-store' });
        if (res2.ok) return await res2.text();
        errors.push(`${prox} → HTTP ${res2.status}`);
      } catch (e2) {
        errors.push(`proxy for ${url} → ${e2?.message || e2}`);
      }
    }
    throw new Error('All fetches failed.\n' + errors.join('\n'));
  }

  async function fetchLoadForecastForISO(iso) {
    if (iso === 'CAISO') {
      const csv = await fetchTextWithFallbacks(CAISO_CSV_URLS);
      return { points: parseCAISOCsv(csv), source: 'CAISO LoadForecast.csv' };
    }
    // TODO: Add ERCOT & others using their public CSVs.
    return { points: [], source: 'No public source wired for this ISO yet' };
  }

  async function geocodeZipOrText(q) {
    const res = await fetch(GEOCODE(q));
    if (!res.ok) throw new Error('Geocoding failed');
    const j = await res.json();
    if (!j.results || !j.results.length) throw new Error('Location not found');
    const r = j.results[0];
    const stateName = r.admin1 || r.admin2 || '';
    const nameToCode = { 'Alabama':'AL','Alaska':'AK','Arizona':'AZ','Arkansas':'AR','California':'CA','Colorado':'CO','Connecticut':'CT','Delaware':'DE','Florida':'FL','Georgia':'GA','Hawaii':'HI','Idaho':'ID','Illinois':'IL','Indiana':'IN','Iowa':'IA','Kansas':'KS','Kentucky':'KY','Louisiana':'LA','Maine':'ME','Maryland':'MD','Massachusetts':'MA','Michigan':'MI','Minnesota':'MN','Mississippi':'MS','Missouri':'MO','Montana':'MT','Nebraska':'NE','Nevada':'NV','New Hampshire':'NH','New Jersey':'NJ','New Mexico':'NM','New York':'NY','North Carolina':'NC','North Dakota':'ND','Ohio':'OH','Oklahoma':'OK','Oregon':'OR','Pennsylvania':'PA','Rhode Island':'RI','South Carolina':'SC','South Dakota':'SD','Tennessee':'TN','Texas':'TX','Utah':'UT','Vermont':'VT','Virginia':'VA','Washington':'WA','West Virginia':'WV','Wisconsin':'WI','Wyoming':'WY','District of Columbia':'DC' };
    const stateCode = nameToCode[stateName] || '';
    return { name: r.name, state: stateName, stateCode, country: (r.country_code||'US').toUpperCase(), lat: r.latitude, lon: r.longitude };
  };

  async function fetchWeatherDaily(lat, lon) {
    const res = await fetch(WEATHER(lat, lon));
    if (!res.ok) throw new Error('Weather fetch failed');
    const j = await res.json();
    return j.daily; // { time:[], temperature_2m_max:[], temperature_2m_min:[] }
  }

  // ======= Chart setup =======
  let chart;
  function buildChart(ctx, seriesLoad, seriesHi, seriesLo) {
    if (chart) chart.destroy();

    const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
    gradient.addColorStop(0, 'rgba(78,161,255,0.45)');
    gradient.addColorStop(1, 'rgba(78,161,255,0.05)');

    chart = new Chart(ctx, {
      type: 'line',
      data: {
        datasets: [
          {
            label: 'ISO Load Forecast (MW)',
            data: seriesLoad,
            parsing: false,
            borderColor: '#4ea1ff',
            backgroundColor: gradient,
            fill: true,
            tension: 0.25,
            pointRadius: 0,
            yAxisID: 'yMW'
          },
          {
            label: 'Daily High (°F)',
            data: seriesHi,
            parsing: false,
            borderColor: '#ff4e4e',
            borderDash: [6, 6],
            fill: false,
            pointRadius: 2,
            yAxisID: 'yT'
          },
          {
            label: 'Daily Low (°F)',
            data: seriesLo,
            parsing: false,
            borderColor: '#2d5cff',
            borderDash: [6, 6],
            fill: false,
            pointRadius: 2,
            yAxisID: 'yT'
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        scales: {
          x: {
            type: 'time',
            time: { unit: 'day', tooltipFormat: 'MMM d, h a' },
            grid: { color: 'rgba(255,255,255,0.05)' },
            ticks: { color: '#cfe0ff' }
          },
          yMW: {
            type: 'linear',
            position: 'left',
            title: { display: true, text: 'Megawatts (MW)' },
            grid: { color: 'rgba(255,255,255,0.06)' },
            ticks: { color: '#cfe0ff' }
          },
          yT: {
            type: 'linear',
            position: 'right',
            title: { display: true, text: 'Temperature (°F)' },
            grid: { drawOnChartArea: false },
            ticks: { color: '#cfe0ff' }
          }
        },
        plugins: {
          legend: { labels: { color: '#d9e4ff' } },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const v = ctx.raw?.y ?? ctx.parsed.y;
                const lbl = ctx.dataset.label || '';
                if (/Load/.test(lbl)) return `${lbl}: ${Math.round(v).toLocaleString()} MW`;
                return `${lbl}: ${Math.round(v)} °F`;
              }
            }
          }
        }
      }
    });
  }

  function prepareDailyTemps(daily) {
    // Place a single point per day at local noon for visual alignment
    const outHi = [], outLo = [];
    for (let i = 0; i < Math.min(10, daily.time.length); i++) {
      const d = new Date(daily.time[i] + 'T12:00:00');
      outHi.push({ x: d, y: daily.temperature_2m_max[i] });
      outLo.push({ x: d, y: daily.temperature_2m_min[i] });
    }
    return { outHi, outLo };
  }

  function limitToHorizon(points, days = 10) {
    const now = new Date();
    const end = new Date(now.getTime() + days*24*3600*1000);
    return points.filter(p => p.x >= now && p.x <= end);
  }

  // ======= App wiring =======
  let autoTimer = null;
  function startAutoRefresh(cb) {
    if (autoTimer) clearInterval(autoTimer);
    autoTimer = setInterval(cb, 60*60*1000); // hourly
  }

  async function loadForQuery(q, { useGeoLoc = false } = {}) {
    try {
      $('#badge-upd').textContent = 'Loading…';
      $('#badge-src').textContent = 'Source: —';

      let loc;
      if (useGeoLoc) {
        const pos = await new Promise((res, rej) => navigator.geolocation.getCurrentPosition(res, rej, { enableHighAccuracy: false, maximumAge: 60_000 }));
        // Reverse geocode not needed for weather; we derive state via nearest location result to coordinates
        const nearest = await fetch(`https://geocoding-api.open-meteo.com/v1/reverse?latitude=${pos.coords.latitude}&longitude=${pos.coords.longitude}&language=en&format=json`);
        const j = await nearest.json();
        const r = j?.results?.[0];
        loc = {
          name: r?.name || 'Current location',
          state: r?.admin1 || '',
          stateCode: (function(){ const m = { 'California':'CA','Texas':'TX','Nevada':'NV','Arizona':'AZ','Oregon':'OR','Washington':'WA','New York':'NY','Massachusetts':'MA','Maine':'ME','New Hampshire':'NH','Rhode Island':'RI','Vermont':'VT','Connecticut':'CT','Pennsylvania':'PA','New Jersey':'NJ','Maryland':'MD','Virginia':'VA','District of Columbia':'DC' }; return m[r?.admin1] || ''; })(),
          country: (r?.country_code || 'US').toUpperCase(),
          lat: pos.coords.latitude,
          lon: pos.coords.longitude
        };
      } else {
        loc = await geocodeZipOrText(q);
      }

      const iso = stateToISO(loc.stateCode);
      $('#badge-iso').textContent = `ISO: ${iso}`;
      $('#where').innerHTML = `<span class="dot ok"></span> <strong>${loc.name}</strong>${loc.state ? `, ${loc.state}` : ''} — ${loc.country} · (${loc.lat.toFixed(3)}, ${loc.lon.toFixed(3)})`;

      const [weather, load] = await Promise.all([
        fetchWeatherDaily(loc.lat, loc.lon),
        fetchLoadForecastForISO(iso)
      ]);

      const { outHi, outLo } = prepareDailyTemps(weather);
      let loadPts = limitToHorizon(load.points, 10);

      // Mild smoothing for visualization (optional)
      // Chart.js tension already smooths; keep raw values

      const ctx = document.getElementById('chart').getContext('2d');
      buildChart(ctx, loadPts, outHi, outLo);

      $('#badge-src').textContent = `Source: ${load.source}`;
      $('#badge-upd').textContent = `Last update: ${fmt.format(new Date())}`;

      // Start hourly refresh for this query
      startAutoRefresh(() => loadForQuery(useGeoLoc ? '' : q, { useGeoLoc }));
    } catch (err) {
      console.error(err);
      $('#where').innerHTML = `<span class="dot err"></span> ${err?.message || err}`;
      $('#badge-upd').textContent = 'Error';
      // Still draw weather if we have it? Handled in try above
    }
  }

  // UI handlers
  document.getElementById('go').addEventListener('click', () => {
    const zip = document.getElementById('zip').value.trim();
    if (!zip) return;
    loadForQuery(zip);
  });
  document.getElementById('zip').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') $('#go').click();
  });
  document.getElementById('loc').addEventListener('click', () => loadForQuery('', { useGeoLoc: true }));

  // Optional: load a sensible default on first visit (San Francisco 94102)
  window.addEventListener('load', () => {
    const urlZip = new URLSearchParams(location.search).get('zip');
    if (urlZip) { $('#zip').value = urlZip; loadForQuery(urlZip); }
    else { $('#zip').value = '94102'; loadForQuery('94102'); }
  });
  </script>
</body>
</html>
