<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ISO Load + Weather — 10-Day Forecast by ZIP</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='8' fill='%23121a33'/%3E%3Cpath d='M36 4L12 36h14l-2 24 30-38H38l-2-18z' fill='%234ea1ff'/%3E%3C/svg%3E">
  <meta name="description" content="Simple, keyless, GitHub-Pages-friendly site: enter a US ZIP, get a 10-day ISO load forecast (area) + daily high/low temps (dotted)." />
  <style>
    :root{
      --bg:#0b1020; /* deep navy */
      --card:#121a33;
      --text:#eaf0ff;
      --muted:#9fb0d9;
      --accent:#4ea1ff;
      --danger:#ff4e4e;
      --ok:#66e;
      --grid:#1c274d;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:radial-gradient(1200px 800px at 15% -5%, #1a2447 0%, #0b1020 50%) fixed;color:var(--text)}
    header{padding:18px 16px;display:flex;gap:12px;align-items:center;flex-wrap:wrap;border-bottom:1px solid #111a33}
    h1{font-size:18px;margin:0;font-weight:700;letter-spacing:.2px}
    .sub{color:var(--muted);font-size:12px}
    .wrap{display:grid;gap:10px;padding:10px;max-width:920px;margin:0 auto}
    .card{background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));border:1px solid #1a2447;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:14px}
    label{display:block;font-weight:600;margin:0 0 8px;color:#cfe0ff}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    input[type="text"]{appearance:none;background:#0f1731;border:1px solid #223061;color:var(--text);padding:12px 14px;border-radius:12px;min-width:220px;font-size:14px;outline:none}
    button{all:unset;display:inline-flex;align-items:center;gap:8px;background:linear-gradient(180deg,#4ea1ff,#2f78ff);color:white;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 6px 16px rgba(46,119,255,.35)}
    button.secondary{background:#0f1731;border:1px solid #223061;color:#bcd0ff;box-shadow:none}
    .hint{color:var(--muted);font-size:12px}
    .status{display:flex;align-items:center;gap:8px;color:#bcd0ff}
    .dot{width:8px;height:8px;border-radius:50%}
    .dot.ok{background:#5ee}
    .dot.warn{background:#ffa95e}
    .dot.err{background:#ff6868}
    canvas{width:100%;height:clamp(220px,38vh,420px);background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));border-radius:12px;border:1px solid #1a2447}
    body.compact canvas{height:clamp(160px,26vh,320px);}
    footer{color:#93a7d9;font-size:12px;display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    code,kbd{background:#0f1731;border:1px solid #223061;color:#bcd0ff;border-radius:6px;padding:0 6px}
    .badgelist{display:flex;flex-wrap:wrap;gap:8px}
    .badge{background:#0f1731;border:1px solid #223061;color:#bcd0ff;border-radius:100px;padding:4px 8px;font-size:12px}
    .sr-only{position:absolute;left:-9999px}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>ISO Load + Weather — 10-Day Forecast</h1>
      <div class="sub">Keyless data sources. GitHub Pages friendly. Auto-updates hourly.</div>
    </div>
  </header>

  <main class="wrap">
    <section class="card">
      <label for="zip">Enter a US ZIP code</label>
      <div class="row">
        <input id="zip" type="text" inputmode="numeric" pattern="[0-9]{5}" maxlength="10" placeholder="e.g., 94102" autocomplete="postal-code" />
        <button id="go">Get forecast</button>
        <button id="loc" class="secondary" title="Use your approximate location (browser prompt)">Use my location</button>
        <select id="isoSelect" class="secondary" title="Force a specific ISO (optional)" style="padding:10px 12px;border-radius:12px;border:1px solid #223061;background:#0f1731;color:#bcd0ff">
          <option value="auto">Auto-detect ISO</option>
          <option value="CAISO">CAISO</option>
          <option value="ERCOT">ERCOT</option>
          <option value="PJM">PJM</option>
          <option value="MISO">MISO</option>
          <option value="SPP">SPP</option>
          <option value="ISONE">ISO-NE</option>
          <option value="NYISO">NYISO</option>
        </select>
      </div>
      <div class="hint">Blue area = ISO load forecast (MW, left axis). ▲ markers = daily peaks. Red dotted = daily high. Dark-blue dotted = daily low (°F, right axis). Refreshes hourly.</div>
    </section>

    <section class="card">
      <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
        <div id="where" class="status">—</div>
        <div class="row" style="gap:10px;align-items:center">
          <div class="badgelist">
            <span class="badge" id="badge-iso">ISO: —</span>
            <span class="badge" id="badge-src">Source: —</span>
            <span class="badge" id="badge-upd">Last update: —</span>
          </div>
          <button id="dlcsv" class="secondary" title="Download the plotted data as CSV">Download CSV<\/button>
          <button id="compact" class="secondary" title="Toggle compact chart height">Compact view<\/button>
        </div>
      </div>
      <canvas id="chart" aria-label="Load and temperature forecast" role="img"></canvas>
      <div class="hint" id="note"></div>
    </section>

    <section class="card">
      <details>
        <summary><strong>About & Data Sources</strong></summary>
        <p><strong>Load forecasts</strong> (hourly unless noted):
          <ul>
            <li>CAISO: Today’s Outlook CSV (<code>LoadForecast.csv</code>), 10-day ahead.</li>
            <li>ERCOT: Dashboards JSON (<code>supply-demand.json</code> for multi-day; fallback <code>todays-outlook.json</code>), ~6-day ahead.</li>
            <li>NYISO: ISO Load Forecast CSV (<code>isolf</code>) by date.</li>
            <li>SPP: Operations Medium-Term Load Forecast CSV (<code>OP-MTLF-YYYYMMDDHH00.csv</code>), 7-day ahead.</li>
            <li>ISO-NE: Three-Day System Demand Forecast CSV (3-day hourly); Seven-Day Capacity Forecast is daily peaks only.</li>
            <li>PJM: Seven-Day Load Forecast (Data Miner 2). Some endpoints may require a PJM account; this page will attempt a public fetch and degrade gracefully.</li>
            <li>MISO: No keyless multi-day hourly load forecast endpoint openly published.</li>
          </ul>
        </p>
        <p><strong>Weather</strong> (daily hi/lo): Open-Meteo Geocoding + Forecast APIs (no key).</p>
        <p class="hint">If an ISO file blocks CORS, this page uses a safe proxy (<code>api.allorigins.win</code>) to read the public file. Some ISOs only provide 3–7 day horizons or daily peaks — the chart reflects what’s available.</p>
      </details>
    </section>

    <footer class="card">
      <div>Credits: CAISO; ERCOT Dashboards; NYISO MIS; SPP Marketplace; ISO-NE ISO-Express; Open-Meteo.</div>
      <div>Made for static hosting — no API keys, no server.</div>
    </footer>
  </main>

  <!-- Libraries (no-build, CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
  // ======= Small util helpers =======
  const $ = sel => document.querySelector(sel);
  const fmt = new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' }

  // ======= ISO detectors =======
  const stateToISO = (stateCode) => {
    const PJM_STATES = new Set(['DC','DE','IL','IN','KY','MD','MI','NJ','NC','OH','PA','TN','VA','WV']);
    const MISO_STATES = new Set(['AR','IL','IN','IA','KY','LA','MI','MN','MO','MS','MT','ND','SD','TX','WI']);
    const SPP_STATES  = new Set(['AR','KS','LA','MN','MO','MT','ND','NE','NM','OK','SD','TX','WY']);
    const ISONE_STATES= new Set(['CT','MA','ME','NH','RI','VT']);
    if (stateCode === 'CA') return 'CAISO';
    if (stateCode === 'TX') return 'ERCOT';
    if (stateCode === 'NY') return 'NYISO';
    if (ISONE_STATES.has(stateCode)) return 'ISONE';
    if (SPP_STATES.has(stateCode)) return 'SPP';
    if (PJM_STATES.has(stateCode)) return 'PJM';
    if (MISO_STATES.has(stateCode)) return 'MISO';
    return 'UNKNOWN';
  };

  // ======= Source: CAISO (10-day) =======
  const CAISO_CSV_URLS = [
    'https://www.caiso.com/outlook/SP/Load/LoadForecast.csv',
    'https://content.caiso.com/outlook/SP/Load/LoadForecast.csv',
    'https://www.caiso.com/outlook/SP/Load/loadforecast.csv',
    'https://content.caiso.com/outlook/SP/Load/loadforecast.csv',
    // http variants (used only through r.jina.ai proxy to avoid mixed-content blocks)
    'http://www.caiso.com/outlook/SP/Load/LoadForecast.csv',
    'http://content.caiso.com/outlook/SP/Load/LoadForecast.csv',
    'http://www.caiso.com/outlook/SP/Load/loadforecast.csv',
    'http://content.caiso.com/outlook/SP/Load/loadforecast.csv',
  ];
  function parseCAISOCsv(text) {
    const parsed = Papa.parse(text.trim(), { header: true });
    if (!parsed.data || !parsed.data.length) throw new Error('Empty CSV');
    const rows = parsed.data;
    const headers = parsed.meta.fields.map(h => h.trim());
    const timeKey = headers.find(h => /time|timestamp|datetime/i.test(h)) || (headers.includes('Date') && headers.includes('HE') ? 'Date' : null);
    const mwKey = headers.find(h => /mw|forecast|load/i.test(h) && !/net|price|temp|solar|wind/i.test(h));
    if (!mwKey) throw new Error('Could not find MW column in CAISO CSV');
    const out = [];
    for (const r of rows) {
      if (!r) continue;
      let t = null;
      if (timeKey === 'Date' && r.Date && r.HE) {
        const he = Number(r.HE);
        if (!Number.isFinite(he)) continue;
        const d = new Date(r.Date);
        if (isNaN(d)) continue;
        d.setHours(he - 1, 0, 0, 0);
        t = d;
      } else if (timeKey && r[timeKey]) {
        const d = new Date(r[timeKey]);
        if (!isNaN(d)) t = d;
      } else { continue; }
      const y = Number(String(r[mwKey]).replace(/,/g, ''));
      if (Number.isFinite(y) && t) out.push({ x: t, y });
    }
    out.sort((a,b)=>a.x-b.x);
    return out;
  }

  // ======= Source: ERCOT (6-day via dashboard JSON; fallback: today only) =======
  async function fetchERCOT() {
    try {
      const j = await fetchJSONWithFallback('https://www.ercot.com/api/1/services/read/dashboards/supply-demand.json');
      const series = (j?.data || j?.currentDay || j?.sixDay || []).data || j?.data || [];
      const baseDate = new Date((j.lastUpdated || '').slice(0, 10));
      const points = [];
      let cursor = new Date(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate(), 0, 0, 0, 0);
      for (const r of series) {
        const t = r.timestamp ? new Date(r.timestamp) : new Date(cursor);
        if (!r.timestamp) cursor = new Date(cursor.getTime() + 5*60*1000);
        const y = Number(r.demand ?? r.systemLoad ?? r.forecastedLoad ?? r.Load ?? r.load);
        if (Number.isFinite(y)) points.push({ x: t, y });
      }
      const hourly = [];
      let lastHour = null;
      for (const p of points) {
        const h = p.x.getFullYear()*10000 + (p.x.getMonth()+1)*100 + p.x.getDate();
        const key = `${h}-${p.x.getHours()}`;
        if (lastHour?.key === key) lastHour.p = p; else { if (lastHour) hourly.push(lastHour.p); lastHour = { key, p }; }
      }
      if (lastHour) hourly.push(lastHour.p);
      return { points: hourly, source: 'ERCOT dashboards supply-demand.json' };
    } catch(_){ }
    const j2 = await fetchJSONWithFallback('https://www.ercot.com/api/1/services/read/dashboards/todays-outlook.json');
    const d0 = new Date(j2.lastUpdated.slice(0,10));
    const out = [];
    let cursor = new Date(d0.getFullYear(), d0.getMonth(), d0.getDate(), 0, 0, 0, 0);
    for (const r of (j2.data||[])) {
      const t = new Date(cursor);
      cursor = new Date(cursor.getTime() + 5*60*1000);
      const y = Number(r.demand ?? r.systemLoad ?? r.forecastedLoad ?? r.Load ?? r.load);
      if (Number.isFinite(y)) out.push({ x: t, y });
    }
    const hourly = [];
    let lastHour = null;
    for (const p of out) {
      const key = p.x.getHours();
      if (lastHour?.key === key) lastHour.p = p; else { if (lastHour) hourly.push(lastHour.p); lastHour = { key, p }; }
    }
    if (lastHour) hourly.push(lastHour.p);
    return { points: hourly, source: 'ERCOT dashboards todays-outlook.json' };
  }

  // ======= Source: NYISO (ISO Load Forecast CSV for given day) =======
  function yyyyMMdd(d){ const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,'0'); const day=String(d.getDate()).padStart(2,'0'); return `${y}${m}${day}`; }
  async function fetchNYISO(){
    const candidates = [];
    const today = new Date();
    for (let k=0;k<2;k++){
      const d = new Date(today.getTime()+k*24*3600*1000);
      candidates.push(`https://mis.nyiso.com/public/csv/isolf/${yyyyMMdd(d)}isolf.csv`);
    }
    const csv = await fetchTextWithFallbacks(candidates);
    const parsed = Papa.parse(csv.trim(), { header: true });
    const fields = parsed.meta.fields.map(s=>s.trim());
    const timeKey = fields.find(f=>/time|timestamp|date/i.test(f)) || fields[0];
    let nycaKey = fields.find(f=>/NYCA|NYISO|NYCA Load/i.test(f));
    const out = [];
    for (const r of parsed.data){
      const t = new Date(r[timeKey]);
      if (isNaN(t)) continue;
      let y;
      if (nycaKey) y = Number(String(r[nycaKey]).replace(/,/g,''));
      else {
        y = 0; let found=false; for (const k of fields){ if (k===timeKey) continue; const v = Number(String(r[k]).replace(/,/g,'')); if (Number.isFinite(v)) { y += v; found=true; } }
        if (!found) continue;
      }
      if (Number.isFinite(y)) out.push({ x: t, y });
    }
    out.sort((a,b)=>a.x-b.x);
    return { points: out, source: 'NYISO ISO Load Forecast (isolf)' };
  }

  // ======= Source: SPP (Medium-Term Load Forecast, 7-day) =======
  function formatSPPPath(dt){
    const y = dt.getFullYear(); const m = String(dt.getMonth()+1).padStart(2,'0'); const d = String(dt.getDate()).padStart(2,'0'); const H = String(dt.getHours()).padStart(2,'0');
    return `/${y}/${m}/${d}/OP-MTLF-${y}${m}${d}${H}00.csv`;
  }
  async function fetchSPP(){
    const base = 'https://portal.spp.org/file-browser-api/download?path=';
    const tries = [];
    const now = new Date();
    for (let i=0;i<8;i++){
      const d = new Date(now.getTime()-i*3600*1000);
      tries.push(base + encodeURIComponent(formatSPPPath(d)));
    }
    const csv = await fetchTextWithFallbacks(tries);
    const parsed = Papa.parse(csv.trim(), { header: true });
    const fields = parsed.meta.fields.map(f=>f.trim());
    const timeKey = fields.find(f=>/interval|time/i.test(f)) || fields[0];
    const mwKey = fields.find(f=>/MTLF|Forecast|Load/i.test(f) && !/Actual/i.test(f)) || fields[1];
    const out = [];
    for (const r of parsed.data){
      const t = new Date(r[timeKey]);
      const y = Number(String(r[mwKey]).replace(/,/g,''));
      if (!isNaN(t) && Number.isFinite(y)) out.push({ x:t, y });
    }
    out.sort((a,b)=>a.x-b.x);
    return { points: out, source: 'SPP OP-MTLF (7-day hourly)' };
  }

  // ======= Source: ISO-NE (3-day hourly system demand forecast) =======
  async function fetchISONE(){
    const listUrl = 'https://www.iso-ne.com/isoexpress/web/reports/load-and-demand/-/tree/three-day-reliability-region-demand-forecast';
    const html = await fetchTextWithFallbacks([listUrl]);
    const doc = new DOMParser().parseFromString(html, 'text/html');
    const a = doc.querySelector('a[href*="transform/csv"]');
    if (!a) throw new Error('ISO-NE CSV link not found');
    const csvUrl = new URL(a.getAttribute('href'), 'https://www.iso-ne.com').toString();
    const csv = await fetchTextWithFallbacks([csvUrl]);
    const parsed = Papa.parse(csv.trim(), { header: true });
    const fields = parsed.meta.fields.map(f=>f.trim());
    const timeKey = fields.find(f=>/Hour|Time|Date/i.test(f)) || fields[0];
    const mwKey = fields.find(f=>/System Load|Demand|MWh|MW/i.test(f) && !/Prior/i.test(f)) || fields[fields.length-1];
    const out = [];
    for (const r of parsed.data){
      const t = new Date(r[timeKey]);
      const y = Number(String(r[mwKey]).replace(/,/g,''));
      if (!isNaN(t) && Number.isFinite(y)) out.push({ x:t, y });
    }
    out.sort((a,b)=>a.x-b.x);
    return { points: out, source: 'ISO-NE Three-Day System Demand Forecast' };
  }

  // ======= Source: PJM (7-day hourly via Data Miner 2; may require account) =======
  async function fetchPJM(){
    try {
      const url = 'https://dataminer2.pjm.com/feed/load_frcstd_7_day';
      const j = await fetchJSONWithFallback(url);
      const rows = j?.rows || j?.data || [];
      const out = [];
      for (const r of rows){
        const t = new Date(r.effective_date || r.datetime_beginning_utc || r.datetime_beginning_ept || r.datetime_beginning || r.interval_start);
        const yRaw = r.rto_total ?? r.rto ?? r.rto_load ?? r.total_forecast_mw ?? r.load_mw ?? r.frcstd_load;
        const y = Number(String(yRaw).replace(/,/g,''));
        if (!isNaN(t) && Number.isFinite(y)) out.push({ x: t, y });
      }
      if (out.length) { out.sort((a,b)=>a.x-b.x); return { points: out, source: 'PJM Data Miner 2 — Seven-Day Load Forecast' }; }
    } catch(_){ }
    try {
      const url2 = 'https://dataminer2.pjm.com/feed/very_short_load_frcst';
      const j2 = await fetchJSONWithFallback(url2);
      const rows2 = j2?.rows || j2?.data || [];
      const out2 = [];
      for (const r of rows2){
        const t = new Date(r.datetime_beginning_ept || r.datetime_beginning_utc || r.effective_date);
        const y = Number(String(r.rto_frcst ?? r.frcst ?? r.load_mw).replace(/,/g,'')); 
        if (!isNaN(t) && Number.isFinite(y)) out2.push({ x: t, y });
      }
      if (out2.length) { out2.sort((a,b)=>a.x-b.x); return { points: out2, source: 'PJM very short load forecast (2-hour)' }; }
    } catch(_){ }
    return { points: [], source: 'PJM public feed not reachable (may require account)' };
  }

  // ======= Source: MISO (placeholder) =======
  async function fetchMISO(){
    return { points: [], source: 'MISO: no keyless multi-day hourly load forecast endpoint available' };
  }

  async function fetchLoadForecastForISO(iso) {
    if (iso === 'CAISO') { const csv = await fetchTextWithFallbacks(CAISO_CSV_URLS); return { points: parseCAISOCsv(csv), source: 'CAISO LoadForecast.csv' }; }
    if (iso === 'ERCOT') return await fetchERCOT();
    if (iso === 'NYISO') return await fetchNYISO();
    if (iso === 'SPP') return await fetchSPP();
    if (iso === 'ISONE') return await fetchISONE();
    if (iso === 'PJM') return await fetchPJM();
    if (iso === 'MISO') return await fetchMISO();
    return { points: [], source: 'No public source wired for this ISO yet' };
  }

  async function geocodeZipOrText(q) {
    const res = await fetch(GEOCODE(q));
    if (!res.ok) throw new Error('Geocoding failed');
    const j = await res.json();
    if (!j.results || !j.results.length) throw new Error('Location not found');
    const r = j.results[0];
    const stateName = r.admin1 || r.admin2 || '';
    const nameToCode = { 'Alabama':'AL','Alaska':'AK','Arizona':'AZ','Arkansas':'AR','California':'CA','Colorado':'CO','Connecticut':'CT','Delaware':'DE','Florida':'FL','Georgia':'GA','Hawaii':'HI','Idaho':'ID','Illinois':'IL','Indiana':'IN','Iowa':'IA','Kansas':'KS','Kentucky':'KY','Louisiana':'LA','Maine':'ME','Maryland':'MD','Massachusetts':'MA','Michigan':'MI','Minnesota':'MN','Mississippi':'MS','Missouri':'MO','Montana':'MT','Nebraska':'NE','Nevada':'NV','New Hampshire':'NH','New Jersey':'NJ','New Mexico':'NM','New York':'NY','North Carolina':'NC','North Dakota':'ND','Ohio':'OH','Oklahoma':'OK','Oregon':'OR','Pennsylvania':'PA','Rhode Island':'RI','South Carolina':'SC','South Dakota':'SD','Tennessee':'TN','Texas':'TX','Utah':'UT','Vermont':'VT','Virginia':'VA','Washington':'WA','West Virginia':'WV','Wisconsin':'WI','Wyoming':'WY','District of Columbia':'DC' };
    const stateCode = nameToCode[stateName] || '';
    return { name: r.name, state: stateName, stateCode, country: (r.country_code||'US').toUpperCase(), lat: r.latitude, lon: r.longitude };
  }

  async function fetchWeatherDaily(lat, lon) {
    const res = await fetch(WEATHER(lat, lon));
    if (!res.ok) throw new Error('Weather fetch failed');
    const j = await res.json();
    return j.daily; // { time:[], temperature_2m_max, temperature_2m_min }
  }

  // ======= Chart + data helpers =======
  let chart;
  let lastData = { load: [], dailyHi: [], dailyLo: [], peaks: [], iso: '', loc: null };

  function buildChart(ctx, seriesLoad, seriesHi, seriesLo, dailyPeaks) {
    if (chart) chart.destroy();

    const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
    gradient.addColorStop(0, 'rgba(78,161,255,0.45)');
    gradient.addColorStop(1, 'rgba(78,161,255,0.05)');

    const datasets = [
      { label: 'ISO Load Forecast (MW)', data: seriesLoad, parsing: false, borderColor: '#4ea1ff', backgroundColor: gradient, fill: true, tension: 0.25, pointRadius: 0, yAxisID: 'yMW' },
      { label: 'Daily High (°F)', data: seriesHi, parsing: false, borderColor: '#ff4e4e', borderDash: [6, 6], fill: false, pointRadius: 2, yAxisID: 'yT' },
      { label: 'Daily Low (°F)', data: seriesLo, parsing: false, borderColor: '#2d5cff', borderDash: [6, 6], fill: false, pointRadius: 2, yAxisID: 'yT' }
    ];

    if (dailyPeaks && dailyPeaks.length) {
      datasets.push({
        label: 'Daily Peak (MW)',
        type: 'scatter',
        data: dailyPeaks,
        parsing: false,
        borderColor: '#4ea1ff',
        backgroundColor: '#ffffff',
        pointStyle: 'triangle',
        pointRadius: 5,
        pointHoverRadius: 7,
        yAxisID: 'yMW'
      });
    }

    chart = new Chart(ctx, {
      type: 'line',
      data: { datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        scales: {
          x: { type: 'time', time: { unit: 'day', tooltipFormat: 'MMM d, h a' }, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#cfe0ff' } },
          yMW: { type: 'linear', position: 'left', title: { display: true, text: 'Megawatts (MW)' }, grid: { color: 'rgba(255,255,255,0.06)' }, ticks: { color: '#cfe0ff' } },
          yT: { type: 'linear', position: 'right', title: { display: true, text: 'Temperature (°F)' }, grid: { drawOnChartArea: false }, ticks: { color: '#cfe0ff' } }
        },
        plugins: { 
          legend: { labels: { color: '#d9e4ff' } },
          tooltip: { callbacks: { label: (ctx) => { const v = ctx.raw?.y ?? ctx.parsed.y; const lbl = ctx.dataset.label || ''; if (/Load|Peak/.test(lbl)) return `${lbl}: ${Math.round(v).toLocaleString()} MW`; return `${lbl}: ${Math.round(v)} °F`; } } } 
        }
      }
    });
  }

  function dateKeyLocal(d) {
    return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
  }

  function computeDailyPeaks(points) {
    const byDay = new Map();
    for (const p of points) {
      const k = dateKeyLocal(p.x);
      const cur = byDay.get(k);
      if (!cur || p.y > cur.y) byDay.set(k, { x: p.x, y: p.y });
    }
    return Array.from(byDay.values()).sort((a,b)=>a.x-b.x);
  }

  function prepareDailyTemps(daily) {
    const outHi = [], outLo = [];
    for (let i = 0; i < Math.min(10, daily.time.length); i++) {
      const d = new Date(daily.time[i] + 'T12:00:00');
      outHi.push({ x: d, y: daily.temperature_2m_max[i] });
      outLo.push({ x: d, y: daily.temperature_2m_min[i] });
    }
    return { outHi, outLo };
  }

  function limitToHorizon(points, days = 10) {
    const now = new Date();
    const end = new Date(now.getTime() + days*24*3600*1000);
    return points.filter(p => p.x >= now && p.x <= end);
  }

  function formatLocalISO(d){
    const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,'0'); const day=String(d.getDate()).padStart(2,'0');
    const hh=String(d.getHours()).padStart(2,'0'); const mm=String(d.getMinutes()).padStart(2,'0');
    const ss=String(d.getSeconds()).padStart(2,'0');
    return `${y}-${m}-${day} ${hh}:${mm}:${ss}`;
  }

  function makeCSV(last){
    const lines = [];
    if (last.load && last.load.length){
      // hourly load rows with daily temps joined by local date
      lines.push(['timestamp_local','timestamp_utc','date_local','iso','location','state_code','latitude','longitude','load_mw','daily_high_f','daily_low_f'].join(','));
      const hiMap = Object.fromEntries((last.dailyHi||[]).map(p=>[dateKeyLocal(p.x), p.y]));
      const loMap = Object.fromEntries((last.dailyLo||[]).map(p=>[dateKeyLocal(p.x), p.y]));
      for (const p of last.load){
        const d = p.x;
        const dk = dateKeyLocal(d);
        const row = [
          formatLocalISO(d),
          new Date(d.getTime()-d.getTimezoneOffset()*60000).toISOString().replace('T',' ').replace('Z',''),
          dk,
          last.iso||'',
          (last.loc?.name||'')+(last.loc?.state?` ${last.loc.state}`:''),
          last.loc?.stateCode||'',
          last.loc?.lat?.toFixed?.(4)||'',
          last.loc?.lon?.toFixed?.(4)||'',
          Math.round(p.y),
          hiMap[dk] ?? '',
          loMap[dk] ?? ''
        ];
        lines.push(row.join(','));
      }
    } else {
      // daily-only fallback
      lines.push(['date_local','iso','location','state_code','latitude','longitude','daily_high_f','daily_low_f'].join(','));
      const mapHi = Object.fromEntries((last.dailyHi||[]).map(p=>[dateKeyLocal(p.x), p.y]));
      const mapLo = Object.fromEntries((last.dailyLo||[]).map(p=>[dateKeyLocal(p.x), p.y]));
      const keys = Array.from(new Set([...Object.keys(mapHi), ...Object.keys(mapLo)])).sort();
      for (const dk of keys){
        const row = [
          dk,
          last.iso||'',
          (last.loc?.name||'')+(last.loc?.state?` ${last.loc.state}`:''),
          last.loc?.stateCode||'',
          last.loc?.lat?.toFixed?.(4)||'',
          last.loc?.lon?.toFixed?.(4)||'',
          mapHi[dk] ?? '',
          mapLo[dk] ?? ''
        ];
        lines.push(row.join(','));
      }
    }
    return lines.join('\n');
  }

  function triggerDownloadCSV(){
    if (!lastData) return;
    const csv = makeCSV(lastData);
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const ts = new Date();
    const stamp = `${ts.getFullYear()}${String(ts.getMonth()+1).padStart(2,'0')}${String(ts.getDate()).padStart(2,'0')}_${String(ts.getHours()).padStart(2,'0')}${String(ts.getMinutes()).padStart(2,'0')}`;
    const fname = `iso_forecast_${(lastData.iso||'ISO')}_${(lastData.loc?.stateCode||'US')}_${stamp}.csv`;
    const a = document.createElement('a');
    a.href = url; a.download = fname; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
  }

  // ======= App wiring =======
  let autoTimer = null;
  function startAutoRefresh(cb) { if (autoTimer) clearInterval(autoTimer); autoTimer = setInterval(cb, 60*60*1000); }

  async function loadForQuery(q, { useGeoLoc = false } = {}) {
    try {
      $('#badge-upd').textContent = 'Loading…';
      $('#badge-src').textContent = 'Source: —';
      $('#note').textContent = '';

      // Resolve location
      let loc;
      if (useGeoLoc) {
        const pos = await new Promise((res, rej) => navigator.geolocation.getCurrentPosition(res, rej, { enableHighAccuracy: false, maximumAge: 60_000 }));
        const nearest = await fetch(`https://geocoding-api.open-meteo.com/v1/reverse?latitude=${pos.coords.latitude}&longitude=${pos.coords.longitude}&language=en&format=json`);
        const j = await nearest.json();
        const r = j?.results?.[0] || {};
        const m = { 'California':'CA','Texas':'TX','Nevada':'NV','Arizona':'AZ','Oregon':'OR','Washington':'WA','New York':'NY','Massachusetts':'MA','Maine':'ME','New Hampshire':'NH','Rhode Island':'RI','Vermont':'VT','Connecticut':'CT','Pennsylvania':'PA','New Jersey':'NJ','Maryland':'MD','Virginia':'VA','District of Columbia':'DC','Illinois':'IL','Indiana':'IN','Ohio':'OH','West Virginia':'WV','Kentucky':'KY','Michigan':'MI','Minnesota':'MN','Missouri':'MO','Iowa':'IA','Wisconsin':'WI','North Dakota':'ND','South Dakota':'SD','Nebraska':'NE','Kansas':'KS','Oklahoma':'OK','Arkansas':'AR','Louisiana':'LA','New Mexico':'NM','Wyoming':'WY','Montana':'MT' };
        loc = { name: r?.name || 'Current location', state: r?.admin1 || '', stateCode: m[r?.admin1] || '', country: (r?.country_code || 'US').toUpperCase(), lat: pos.coords.latitude, lon: pos.coords.longitude };
      } else {
        loc = await geocodeZipOrText(q);
      }

      // Determine ISO (allow override)
      const forcedIso = $('#isoSelect').value;
      const urlIso = new URLSearchParams(location.search).get('iso');
      const iso = (forcedIso && forcedIso !== 'auto') ? forcedIso : (urlIso || stateToISO(loc.stateCode));

      $('#badge-iso').textContent = `ISO: ${iso}`;
      $('#where').innerHTML = `<span class="dot ok"></span> <strong>${loc.name}</strong>${loc.state ? `, ${loc.state}` : ''} — ${loc.country} · (${loc.lat.toFixed(3)}, ${loc.lon.toFixed(3)})`;

      // Fetch weather + load
      const [weather, load] = await Promise.allSettled([
        fetchWeatherDaily(loc.lat, loc.lon),
        fetchLoadForecastForISO(iso)
      ]);

      const daily = weather.status === 'fulfilled' ? weather.value : null;
      const { outHi, outLo } = daily ? prepareDailyTemps(daily) : { outHi: [], outLo: [] };

      let loadPts = (load.status === 'fulfilled' ? load.value.points : []) || [];
      const sourceTxt = (load.status === 'fulfilled' ? load.value.source : 'Load source unavailable');

      loadPts = limitToHorizon(loadPts, 10);
      const peaks = computeDailyPeaks(loadPts);

      const ctx = document.getElementById('chart').getContext('2d');
      buildChart(ctx, loadPts, outHi, outLo, peaks);

      // Save last data for CSV
      lastData = { load: loadPts, dailyHi: outHi, dailyLo: outLo, peaks, iso, loc };

      $('#badge-src').textContent = `Source: ${sourceTxt}`;
      $('#badge-upd').textContent = `Last update: ${fmt.format(new Date())}`;

      if (!loadPts.length) {
        $('#note').textContent = 'Note: This ISO did not return a keyless multi-day hourly load forecast. Showing weather only.';
      } else if (iso === 'ISONE') {
        $('#note').textContent = 'Note: ISO-NE provides 3-day hourly forecast via ISO-Express; seven-day product is daily peaks only.';
      }

      // Start hourly refresh for this query
      startAutoRefresh(() => loadForQuery(useGeoLoc ? '' : q, { useGeoLoc }));
    } catch (err) {
      console.error(err);
      $('#where').innerHTML = `<span class="dot err"></span> ${err?.message || err}`;
      $('#badge-upd').textContent = 'Error';
    }
  }

  // UI handlers
  document.getElementById('go').addEventListener('click', () => {
    const zip = document.getElementById('zip').value.trim();
    if (!zip) return;
    loadForQuery(zip);
  });
  document.getElementById('zip').addEventListener('keydown', (e) => { if (e.key === 'Enter') $('#go').click(); });
  document.getElementById('loc').addEventListener('click', () => loadForQuery('', { useGeoLoc: true }));
  document.getElementById('isoSelect').addEventListener('change', () => {
    const zip = document.getElementById('zip').value.trim();
    loadForQuery(zip || '94102');
  });
  document.getElementById('dlcsv').addEventListener('click', triggerDownloadCSV);
  // Compact view toggle
  function applyCompact(on){ document.body.classList.toggle('compact', !!on); }
  try { applyCompact(localStorage.getItem('compact') === '1'); } catch {}
  document.getElementById('compact').addEventListener('click', () => {
    const on = !document.body.classList.contains('compact');
    applyCompact(on);
    try { localStorage.setItem('compact', on ? '1' : '0'); } catch {}
  });

  // Default on first visit (San Francisco 94102) or URL params
  window.addEventListener('load', () => {
    const params = new URLSearchParams(location.search);
    const urlZip = params.get('zip');
    const urlIso = params.get('iso');
    if (urlIso) $('#isoSelect').value = urlIso;
    if (urlZip) { $('#zip').value = urlZip; loadForQuery(urlZip); }
    else { $('#zip').value = '94102'; loadForQuery('94102'); }
  });
  </script>
</body>
</html>
