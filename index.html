<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>30 Day Weather & Grid Forecast — ISO Load + Weather</title>
<meta name="description" content="ISO hourly load (EIA v2) with 30-day outlook + 30-day daily high/low temps from forecast + 3-year climatology." />
<style>
  :root{--bg:#0b0f17;--fg:#e8ecf3;--muted:#9aa7b1;--card:#111726;--accent:#4ea1ff}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:16px 20px;border-bottom:1px solid #1e2535;flex-wrap:wrap}
  h1{font-size:1.05rem;margin:0}
  .meta{color:var(--muted);font-size:.9rem}
  .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  select,input,button{background:#0e1524;color:var(--fg);border:1px solid #20304b;border-radius:10px;padding:8px 10px}
  button{cursor:pointer}
  main{padding:16px}
  .grid{display:grid;gap:16px}
  @media(min-width:1100px){.grid{grid-template-columns:1fr 1fr}}
  .card{background:var(--card);border:1px solid #1b2334;border-radius:16px;padding:16px;box-shadow:0 6px 20px rgba(0,0,0,.25)}
  .title{font-weight:600;margin:0 0 8px 0}
  #statusLoad,#statusWx{font-size:.9rem;color:var(--muted);margin-top:8px;min-height:1.4em;white-space:pre-wrap}
  canvas{width:100%;height:440px;display:block}
  footer{padding:12px 20px;color:var(--muted);font-size:.85rem}
  a{color:var(--accent);text-decoration:none} a:hover{text-decoration:underline}
</style>
<!-- Chart.js only (adapter-free, category x-axes) -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
<header>
  <div>
    <h1>30 Day Weather & Grid Forecast</h1>
    <div class="meta">Load: EIA v2 Actuals (D) + ISO Forecast (DF) + 3-yr climatology fill. Weather: 30-day daily highs/lows (Open-Meteo forecast + 3-yr climatology fill).</div>
  </div>
  <div class="controls">
    <label>ISO
      <select id="isoSelect">
        <option value="CISO">CAISO</option><option value="PJM">PJM</option>
        <option value="MISO">MISO</option><option value="SPP">SPP</option>
        <option value="ISNE">ISO-NE</option><option value="NYIS">NYISO</option>
        <option value="ERCO">ERCOT</option>
      </select>
    </label>
    <label>History (days)
      <input id="histDays" type="number" min="7" max="60" step="1" value="7" />
    </label>
    <label>ZIP
      <input id="zipInput" type="text" inputmode="numeric" pattern="[0-9]{5}" placeholder="e.g., 90012" value="90012" />
    </label>
    <button id="runBtn">Run</button>
  </div>
</header>

<main>
  <div class="grid">
    <div class="card">
      <p class="title">ISO Load (Actuals + 30-Day Forecast)</p>
      <canvas id="loadChart"></canvas>
      <div id="statusLoad">Ready.</div>
    </div>
    <div class="card">
      <p class="title">Weather — 30-Day Daily High/Low</p>
      <canvas id="wxChart"></canvas>
      <div id="statusWx">Ready.</div>
    </div>
  </div>
</main>

<footer>
  EIA key embedded per request. Weather via Open-Meteo (no key): forecast for available days, then climatology fill from prior 3 years for remaining days.
</footer>

<script>
/* =========================
   Global error capture
========================= */
window.addEventListener('error', e => {
  const el1=document.getElementById('statusLoad'), el2=document.getElementById('statusWx');
  const msg = e.message || (e.error && e.error.toString()) || 'error';
  if (el1) el1.textContent += '\\nJS error: ' + msg;
  if (el2) el2.textContent += '\\nJS error: ' + msg;
});
window.addEventListener('unhandledrejection', e => {
  const el1=document.getElementById('statusLoad'), el2=document.getElementById('statusWx');
  const msg = (e && e.reason && (e.reason.message||e.reason.toString())) || 'unhandled promise rejection';
  if (el1) el1.textContent += '\\nPromise error: ' + msg;
  if (el2) el2.textContent += '\\nPromise error: ' + msg;
});

/* =========================
   Config & Utilities
========================= */
const EIA_API_KEY = 'DDtDBwdrxbGSSPNQBFP2JWvWDfSxTeVzg7qFWBfI';
const EIA_BASE = 'https://api.eia.gov/v2/electricity/rto/region-data/data/';
const STATUS_LOAD = document.getElementById('statusLoad');
const STATUS_WX = document.getElementById('statusWx');
const isoSelect = document.getElementById('isoSelect');
const histDaysInput = document.getElementById('histDays');
const zipInput = document.getElementById('zipInput');
const runBtn = document.getElementById('runBtn');

function pad(n){ return String(n).padStart(2,'0'); }
function toDateStr(d){ return d.getFullYear()+'-'+pad(d.getMonth()+1)+'-'+pad(d.getDate()); }
function fromDateStr(s){ const [y,m,d]=s.split('-').map(x=>parseInt(x,10)); return new Date(y, m-1, d); }
function addDaysStr(s, n){ const d = fromDateStr(s); d.setDate(d.getDate()+n); return toDateStr(d); }
function addHours(d,h){ return new Date(d.getTime() + h*3600*1000); }
function clone(d){ return new Date(d.getTime()); }
function toISOz(d){ return d.toISOString().replace(/\.\d{3}Z$/,'Z'); }
function fail(el, msg, err){ console.error(msg, err||''); el.textContent = 'Error: '+msg+(err&&err.message? ' — '+err.message : ''); }

/* =========================
   EIA Fetch + Processing
   (explicit data[]=value + frequency=hourly)
========================= */
async function fetchEIA(paramsObj, maxPages=10){
  const params = new URLSearchParams(paramsObj);
  params.set('api_key', EIA_API_KEY);
  if (!params.get('data[]') && !params.get('data[0]')) params.append('data[]','value');
  if (!params.get('frequency')) params.set('frequency','hourly');
  if (!params.get('sort[0][column]')) { params.set('sort[0][column]','period'); params.set('sort[0][direction]','asc'); }
  let out=[], offset=0, length=5000;
  for (let i=0;i<maxPages;i++){
    params.set('offset',offset); params.set('length',length);
    const res = await fetch(EIA_BASE + '?' + params.toString());
    if (!res.ok) throw new Error('EIA '+res.status+' '+res.statusText);
    const json = await res.json();
    const rows = (json && json.response && json.response.data) ? json.response.data : [];
    out = out.concat(rows);
    const total = (json && json.response && typeof json.response.total==='number') ? json.response.total : rows.length;
    offset += rows.length;
    if (offset >= total || rows.length===0) break;
  }
  return out;
}
async function getActuals(region, start, end){
  const rows = await fetchEIA({ 'facets[type][]':'D','facets[region][]':region, start:toISOz(start), end:toISOz(end) });
  const out=[]; for (let i=0;i<rows.length;i++){ const r=rows[i], t=new Date(r.period), v=Number(r.value); if (isFinite(t)&&isFinite(v)) out.push({t,v}); }
  return out;
}
async function getISOForecast(region, start, end){
  try{
    const rows = await fetchEIA({ 'facets[type][]':'DF','facets[region][]':region, start:toISOz(start), end:toISOz(end) });
    const out=[]; for (let i=0;i<rows.length;i++){ const r=rows[i], t=new Date(r.period), v=Number(r.value); if (isFinite(t)&&isFinite(v)) out.push({t,v}); }
    return out;
  }catch(e){ console.warn('DF fetch failed', e); return []; }
}
async function getClimatologyFill(region, targetStart, targetEnd){
  const buckets = new Map();
  function push(d,val){
    const k = (d.getUTCMonth()+1)+'-'+d.getUTCDate()+'-'+d.getUTCHours();
    const arr = buckets.get(k); if (arr) arr.push(val); else buckets.set(k,[val]);
  }
  const years=[1,2,3];
  for (let yi=0; yi<years.length; yi++){
    const y = years[yi];
    const s = new Date(Date.UTC(targetStart.getUTCFullYear()-y, targetStart.getUTCMonth(), targetStart.getUTCDate(), targetStart.getUTCHours()));
    const e = new Date(Date.UTC(targetEnd.getUTCFullYear()-y, targetEnd.getUTCMonth(), targetEnd.getUTCDate(), targetEnd.getUTCHours()));
    try{ const ser = await getActuals(region, s, e); for (let i=0;i<ser.length;i++) push(ser[i].t, ser[i].v); }catch(err){ console.warn('Climo year -'+y+' failed', err); }
  }
  const out=[]; for (let t=clone(targetStart); t<=targetEnd; t=addHours(t,1)){
    const k=(t.getUTCMonth()+1)+'-'+t.getUTCDate()+'-'+t.getUTCHours(); const arr=buckets.get(k)||[];
    if (arr.length){ let sum=0; for (let i=0;i<arr.length;i++) sum+=arr[i]; out.push({ t:clone(t), v: sum/arr.length }); }
  }
  return out;
}
async function build30DayForecast(region){
  const now = new Date();
  const startF = addHours(now,1), endF = addHours(now, 24*30);
  const df = await getISOForecast(region, startF, endF);
  const lastDF = df.length ? df[df.length-1].t : new Date(now.getTime());
  let clima=[]; const needStart = addHours(lastDF,1); if (needStart<=endF) clima = await getClimatologyFill(region, needStart, endF);
  const map=new Map(); for (let i=0;i<df.length;i++) map.set(+df[i].t, true);
  const merged=df.slice(); for (let i=0;i<clima.length;i++) if (!map.has(+clima[i].t)) merged.push(clima[i]);
  merged.sort((a,b)=>a.t-b.t);
  return { series: merged, dfHours: df.length };
}

/* =========================
   Weather (Open-Meteo) — 30-day daily highs/lows
========================= */
// 1) ZIP → lat/lon (zippopotam.us)
async function zipToLatLon(zip){
  const r = await fetch('https://api.zippopotam.us/us/'+zip);
  if (!r.ok) throw new Error('ZIP lookup failed ('+r.status+')');
  const j = await r.json(); const p = j && j.places && j.places[0]; if (!p) throw new Error('ZIP not found');
  return { lat: parseFloat(p.latitude), lon: parseFloat(p.longitude) };
}
// 2) Open-Meteo daily forecast (F) for ~16 days
async function getOMDailyForecast(lat, lon){
  const url = 'https://api.open-meteo.com/v1/forecast'
            + '?latitude='+lat+'&longitude='+lon
            + '&daily=temperature_2m_max,temperature_2m_min'
            + '&forecast_days=16'
            + '&temperature_unit=fahrenheit'
            + '&timezone=auto';
  const r = await fetch(url);
  if (!r.ok) throw new Error('Open-Meteo forecast failed ('+r.status+')');
  const j = await r.json();
  const d = j && j.daily ? j.daily : null;
  if (!d || !d.time) return [];
  const out=[];
  for (let i=0;i<d.time.length;i++){
    const day = d.time[i];
    const tmax = Number(d.temperature_2m_max[i]);
    const tmin = Number(d.temperature_2m_min[i]);
    if (isFinite(tmax) && isFinite(tmin)) out.push({ date: day, tmax, tmin });
  }
  return out;
}
// 3) Open-Meteo archive for same 30-day window in each of prior 3 years
async function getOMArchive(lat, lon, startStr, endStr, yearsBack){
  // yearsBack = 1,2,3 (one call per year)
  const start = fromDateStr(startStr); start.setFullYear(start.getFullYear()-yearsBack);
  const end = fromDateStr(endStr); end.setFullYear(end.getFullYear()-yearsBack);
  const s = toDateStr(start), e = toDateStr(end);
  const url = 'https://archive-api.open-meteo.com/v1/archive'
            + '?latitude='+lat+'&longitude='+lon
            + '&start_date='+s+'&end_date='+e
            + '&daily=temperature_2m_max,temperature_2m_min'
            + '&temperature_unit=fahrenheit'
            + '&timezone=auto';
  const r = await fetch(url);
  if (!r.ok) throw new Error('Open-Meteo archive failed ('+r.status+')');
  const j = await r.json();
  const d = j && j.daily ? j.daily : null;
  if (!d || !d.time) return [];
  const out=[];
  for (let i=0;i<d.time.length;i++){
    const day = d.time[i];
    const tmax = Number(d.temperature_2m_max[i]);
    const tmin = Number(d.temperature_2m_min[i]);
    if (isFinite(tmax) && isFinite(tmin)) out.push({ date: day, tmax, tmin });
  }
  return out;
}
// 4) Build 30-day series: prefer forecast; fill remainder with 3-yr mean for same dates
async function build30DayDailyHiLo(lat, lon){
  const startStr = toDateStr(new Date());        // today (local)
  const endStr = addDaysStr(startStr, 29);       // inclusive, 30 days
  const labels = []; for (let i=0;i<30;i++) labels.push(addDaysStr(startStr,i));

  // fetch forecast
  let forecast = [];
  try{ forecast = await getOMDailyForecast(lat, lon); } catch(e){ console.warn(e); forecast = []; }
  const fMap = new Map(); // date -> {tmax,tmin}
  for (let i=0;i<forecast.length;i++) fMap.set(forecast[i].date, { tmax:forecast[i].tmax, tmin:forecast[i].tmin });

  // for remaining dates, compute climatology mean across prior 3 years
  const needStart = forecast.length ? forecast[forecast.length-1].date : startStr;
  // but we still compute climo across entire window; we'll only use it where forecast missing
  const [y1,y2,y3] = await Promise.all([
    getOMArchive(lat, lon, startStr, endStr, 1).catch(_=>[]),
    getOMArchive(lat, lon, startStr, endStr, 2).catch(_=>[]),
    getOMArchive(lat, lon, startStr, endStr, 3).catch(_=>[])
  ]);
  // Build maps for each year
  function arrToMap(arr){ const m=new Map(); for (let i=0;i<arr.length;i++) m.set(arr[i].date, arr[i]); return m; }
  const m1=arrToMap(y1), m2=arrToMap(y2), m3=arrToMap(y3);

  const hi=[], lo=[], src=[]; // src: 'F' forecast, 'C' climatology
  for (let i=0;i<labels.length;i++){
    const d = labels[i];
    if (fMap.has(d)){
      const v=fMap.get(d);
      hi.push(v.tmax); lo.push(v.tmin); src.push('F');
    } else {
      // same month-day in prior 3 years: build dates for those years
      const dt = fromDateStr(d);
      const d1 = toDateStr(new Date(dt.getFullYear()-1, dt.getMonth(), dt.getDate()));
      const d2 = toDateStr(new Date(dt.getFullYear()-2, dt.getMonth(), dt.getDate()));
      const d3 = toDateStr(new Date(dt.getFullYear)-3); // placeholder (fixed below)
    }
  }
  // Fix: build proper prior-year dates for each label
  for (let i=0;i<labels.length;i++){
    if (src[i]==='F') continue;
    const d = labels[i]; const dt = fromDateStr(d);
    const d1 = toDateStr(new Date(dt.getFullYear()-1, dt.getMonth(), dt.getDate()));
    const d2 = toDateStr(new Date(dt.getFullYear()-2, dt.getMonth(), dt.getDate()));
    const d3 = toDateStr(new Date(dt.getFullYear()-3, dt.getMonth(), dt.getDate()));
    const valsMax=[], valsMin=[];
    if (m1.has(d1)) { valsMax.push(m1.get(d1).tmax); valsMin.push(m1.get(d1).tmin); }
    if (m2.has(d2)) { valsMax.push(m2.get(d2).tmax); valsMin.push(m2.get(d2).tmin); }
    if (m3.has(d3)) { valsMax.push(m3.get(d3).tmax); valsMin.push(m3.get(d3).tmin); }
    if (valsMax.length){
      const avgMax = valsMax.reduce((a,b)=>a+b,0)/valsMax.length;
      const avgMin = valsMin.reduce((a,b)=>a+b,0)/valsMin.length;
      hi[i] = avgMax; lo[i] = avgMin; src[i]='C';
    } else {
      hi[i] = null; lo[i] = null; src[i]='?';
    }
  }
  const usedForecast = src.filter(s=>s==='F').length;
  const usedClimo = src.filter(s=>s==='C').length;
  return { labels, hi, lo, usedForecast, usedClimo };
}

/* =========================
   Charts (adapter-free category)
========================= */
let loadChart, wxChart;
function makeLine(ctx, label1, label2){
  return new Chart(ctx, {
    type:'line',
    data:{ labels:[], datasets:[
      { label: label1, data:[], borderWidth:2, tension:0.2, pointRadius:0, spanGaps:true },
      { label: label2, data:[], borderWidth:2, tension:0.2, pointRadius:0, spanGaps:true }
    ]},
    options:{
      responsive:true, maintainAspectRatio:false, interaction:{mode:'index',intersect:false},
      plugins:{ legend:{ labels:{ color:'#dbe6f2', usePointStyle:true } } },
      scales:{
        x:{ type:'category', ticks:{ color:'#b8c2cc', maxRotation:0, autoSkip:true, autoSkipPadding:16 }, grid:{color:'rgba(255,255,255,0.06)'} },
        y:{ ticks:{ color:'#b8c2cc' }, grid:{ color:'rgba(255,255,255,0.06)' } }
      }
    }
  });
}
function ensureLoadChart(){ if (loadChart) return loadChart; const ctx=document.getElementById('loadChart').getContext('2d'); loadChart=makeLine(ctx,'Actual Load (MW)','ISO Forecast (MW)'); return loadChart; }
function ensureWxChart(){ if (wxChart) return wxChart; const ctx=document.getElementById('wxChart').getContext('2d'); wxChart=makeLine(ctx,'Daily High (°F)','Daily Low (°F)'); return wxChart; }

/* =========================
   Render
========================= */
async function render(){
  const region = isoSelect.value;
  const histDays = Math.max(7, Math.min(60, parseInt(histDaysInput.value||'7',10)));
  const zip = (zipInput.value||'').trim();

  /* Load chart (unchanged) */
  STATUS_LOAD.textContent = 'Loading '+region+' actuals ('+histDays+'d) + 30-day forecast…';
  try{
    const now = new Date();
    const actuals = await getActuals(region, addHours(now,-24*histDays), now);
    const forecastObj = await build30DayForecast(region);

    // Merge labels
    const toLabel = (d)=> d.getFullYear()+'-'+pad(d.getMonth()+1)+'-'+pad(d.getDate())+' '+pad(d.getHours())+':'+pad(d.getMinutes());
    const aLabels = actuals.map(p=> toLabel(p.t));
    const aValues = actuals.map(p=> p.v);
    const fLabels = forecastObj.series.map(p=> toLabel(p.t));
    const fValues = forecastObj.series.map(p=> p.v);
    const labelSet = new Set(aLabels.concat(fLabels));
    const labels = Array.from(labelSet).sort();

    const aBy = new Map(); for (let i=0;i<aLabels.length;i++) aBy.set(aLabels[i], aValues[i]);
    const fBy = new Map(); for (let i=0;i<fLabels.length;i++) fBy.set(fLabels[i], fValues[i]);

    const dsActuals=[], dsForecast=[];
    for (let i=0;i<labels.length;i++){
      const L = labels[i];
      dsActuals.push(aBy.has(L) ? aBy.get(L) : null);
      dsForecast.push(fBy.has(L) ? fBy.get(L) : null);
    }

    const lc = ensureLoadChart();
    lc.data.labels = labels;
    lc.data.datasets[0].data = dsActuals;
    lc.data.datasets[1].data = dsForecast;
    lc.update();

    const aFirst = aLabels[0], aLast = aLabels.length ? aLabels[aLabels.length-1] : '—';
    const fFirst = fLabels[0], fLast = fLabels.length ? fLabels[fLabels.length-1] : '—';
    STATUS_LOAD.textContent = 'Actuals: '+(aLabels.length?aFirst+' — '+aLast:'—')+'; Forecast: '+(fLabels.length?fFirst+' — '+fLast:'—')+' (ISO DF hours: '+forecastObj.dfHours+').';
  }catch(err){
    fail(STATUS_LOAD, 'Load series failed', err);
  }

  /* 30-day daily high/low from ZIP */
  if (!/^[0-9]{5}$/.test(zip)) {
    STATUS_WX.textContent = 'Enter a 5-digit ZIP to load weather.';
    return;
  }
  STATUS_WX.textContent = 'Building 30-day daily highs/lows for ZIP '+zip+'…';
  try{
    const { lat, lon } = await zipToLatLon(zip);
    const { labels, hi, lo, usedForecast, usedClimo } = await build30DayDailyHiLo(lat, lon);

    const wc = ensureWxChart();
    wc.data.labels = labels;
    wc.data.datasets[0].data = hi;   // Daily High
    wc.data.datasets[1].data = lo;   // Daily Low
    wc.update();

    STATUS_WX.textContent = '30-day highs/lows built. Forecast days used: '+usedForecast+'; Climatology fill days: '+usedClimo+'.';
  }catch(err){
    fail(STATUS_WX, 'Weather series failed', err);
  }
}

document.getElementById('runBtn').addEventListener('click', render);
window.addEventListener('DOMContentLoaded', render);
</script>
</body>
</html>
