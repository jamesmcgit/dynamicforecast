<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>US ISO Demand ‚Äî 7‚ÄëDay Lookback & 10‚ÄëDay Outlook</title>
  <meta name="description" content="US‚Äëonly (EIA‚Äë930) dashboard: 7‚Äëday lookback of hourly demand + 10‚Äëday temperature‚Äëdriven outlook. Uses chunked EIA v2 calls, robust fallbacks, and throttling to avoid 429/500s." />
  <style>
    :root{ --bg:#0b0c10; --muted:#9aa3af; --text:#f1f5f9 }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font:14px/1.55 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;background:var(--bg);color:var(--text)}
    header{padding:18px 16px;border-bottom:1px solid #1f2430;background:linear-gradient(180deg,#0f1117,#0b0c10)}
    h1{margin:0;font-size:clamp(16px,2.3vw,22px)}
    .sub{color:var(--muted);font-size:12.5px;margin-top:6px}
    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;align-items:center}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:8px 10px;border:1px solid #1f2430;border-radius:10px;background:#0d1016;color:var(--text)}
    .pill input{background:transparent;border:none;color:var(--text);outline:none;min-width:260px}
    .pill select{background:transparent;border:none;color:var(--text);outline:none;min-width:180px}
    .pill option{color:#0b0c10}
    .btn{cursor:pointer;border:1px solid #1f2430;border-radius:10px;background:#0d1016;color:var(--text);padding:8px 10px}
    .btn:hover{background:#131722}
    .grid{display:grid;gap:14px;padding:16px;grid-template-columns:repeat(auto-fill,minmax(360px,1fr))}
    .card{background:#0f1218;border:1px solid #1f2430;border-radius:16px;overflow:hidden;display:flex;flex-direction:column}
    .card header{display:flex;justify-content:space-between;align-items:center;background:transparent;border:0;padding:12px 12px 0}
    .card h2{font-size:16px;margin:0}
    .meta{color:var(--muted);font-size:12px}
    .tabs{display:flex;gap:6px;padding:0 12px 8px}
    .tab{padding:7px 9px;border-radius:999px;border:1px solid #1f2430;background:#0d1016;color:var(--text);cursor:pointer;font-size:12px}
    .tab[aria-selected="true"]{background:#122031;border-color:#1e3a8a;color:#cfe1ff}
    canvas{display:block;width:100%;height:300px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .badge{display:inline-flex;align-items:center;gap:6px;background:#0d1016;border:1px solid #1f2430;border-radius:999px;padding:6px 8px;color:#cbd5e1;font-size:12px}
    .dot{width:8px;height:8px;border-radius:50%}
    .dot.mw{background:#60a5fa}
    .dot.temp{background:#f87171}
    .dot.tmin{background:#10b981}
    .dot.tmax{background:#f59e0b}
    .small{font-size:11px;color:#9aa3af}
    .loading{padding:12px}
    .err{color:#ff8a8a}
    footer{padding:16px;color:#9aa3af;font-size:12px;text-align:center}
  </style>

  <!-- Perf hints + CDN fallbacks for libs -->
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="dns-prefetch" href="https://unpkg.com">

  <!-- Chart.js (UMD) with fallback -->
  <script
    src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"
    defer crossorigin="anonymous"
    onerror="this.onerror=null;this.src='https://unpkg.com/chart.js@4.4.6/dist/chart.umd.min.js'">
  </script>

  <!-- Luxon (global) with fallback -->
  <script
    src="https://cdn.jsdelivr.net/npm/luxon@3.5.0/build/global/luxon.min.js"
    defer crossorigin="anonymous"
    onerror="this.onerror=null;this.src='https://unpkg.com/luxon@3.5.0/build/global/luxon.min.js'">
  </script>

  <!-- Chart.js adapter for Luxon (explicit UMD) with fallback -->
  <script
    src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"
    defer crossorigin="anonymous"
    onerror="this.onerror=null;this.src='https://unpkg.com/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js'">
  </script>

  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ctext y='14' font-size='14'%3E%E2%9A%A1%3C/text%3E%3C/svg%3E">
</head>
<body>
  <header>
    <h1>US ISO Demand ‚Äî 7‚ÄëDay Lookback & 10‚ÄëDay Outlook</h1>
    <div class="sub">Hourly demand (MW) + temperatures (¬∞F), temp‚Äëbased 10‚Äëday demand outlook & predicted peak hour. US only (EIA‚Äë930). Chunked API calls + throttling.</div>
    <div class="controls">
      <label class="pill" title="Your EIA API key">
        <span>üîë EIA API Key</span>
        <input id="eiaKey" placeholder="paste your key‚Ä¶" autocomplete="off" />
      </label>
      <label class="pill" title="Optional proxy base (Netlify/Cloudflare)">
        <span>üåê Proxy (optional)</span>
        <input id="proxyBase" placeholder="https://YOUR-SITE.netlify.app/.netlify/functions" autocomplete="off" />
      </label>
      <label class="pill" title="Weather provider">
        <span>üå¶Ô∏è Weather</span>
        <select id="wxProvider">
          <option value="open-meteo">Open‚ÄëMeteo</option>
          <option value="visualcrossing">Visual Crossing</option>
        </select>
      </label>
      <label class="pill" title="Weather API key (provider‚Äëspecific)">
        <span>üîë WX Key</span>
        <input id="wxKey" placeholder="Visual Crossing key (optional)" autocomplete="off" />
      </label>
      <button class="btn" id="save">Save</button>
      <span class="small" id="status"></span>
    </div>
  </header>

  <main class="grid" id="grid"></main>

  <footer>
    Data: EIA‚Äë930 hourly BA operations (demand) + Visual Crossing (default) or Open‚ÄëMeteo hourly temps. Forecast = quadratic temp‚Äësensitivity per hour of day fit on 7‚Äëday lookback. For planning only.
  </footer>

  <script>
  // ====== LIB ASSERT ======
  function assertLibs(){
    if(!window.Chart) throw new Error('Chart.js failed to load');
    if(!(window.luxon && window.luxon.DateTime)) throw new Error('Luxon failed to load');
    const hasAdapter = (Chart && Chart.registry && Chart.registry.adapters && Chart.registry.adapters._date) || (Chart && Chart._adapters && Chart._adapters._date);
    if(!hasAdapter) throw new Error('chartjs-adapter-luxon failed to load');
  }

  // ====== CONFIG ======
  const DEFAULT_EIA_KEY = 'UCb8mhqSXXtvgaHkGD6d1yw3j56hR541PXrbdZ49';
  try { if(!localStorage.getItem('EIA_API_KEY')) localStorage.setItem('EIA_API_KEY', DEFAULT_EIA_KEY); } catch(_) { /* storage may be disabled */ }
  const DEFAULT_WX_KEY = '4NE3QKKV57NYKGH7F9KM4NMVL';
  try {
    if(!localStorage.getItem('WX_API_KEY')) localStorage.setItem('WX_API_KEY', DEFAULT_WX_KEY);
    if(!localStorage.getItem('WX_PROVIDER')) localStorage.setItem('WX_PROVIDER','visualcrossing');
  } catch(_) {}
  const PROXY_BASE = localStorage.getItem('PROXY_BASE') || '';
  const EIA_PATH   = (new URLSearchParams(location.search).get('path') || localStorage.getItem('EIA_PATH') || 'region-data').toLowerCase();
  const WX_PROVIDER = (new URLSearchParams(location.search).get('wx') || localStorage.getItem('WX_PROVIDER') || 'visualcrossing').toLowerCase();
  const WX_API_KEY  = localStorage.getItem('WX_API_KEY') || DEFAULT_WX_KEY;

  const ISOS = [
    { id: 'CISO', name: 'CAISO', tz: 'America/Los_Angeles', lat: 36.77, lon: -119.42 },
    { id: 'ERCO', name: 'ERCOT', tz: 'America/Chicago',      lat: 31.0,  lon: -99.0  },
    { id: 'MISO', name: 'MISO',  tz: 'America/Chicago',      lat: 41.0,  lon: -93.0  },
    { id: 'PJM',  name: 'PJM',   tz: 'America/New_York',     lat: 39.8,  lon: -77.0  },
    { id: 'NYIS', name: 'NYISO', tz: 'America/New_York',     lat: 42.9,  lon: -75.0  },
    { id: 'ISNE', name: 'ISO‚ÄëNE',tz: 'America/New_York',     lat: 42.36, lon: -71.06 },
    { id: 'SWPP', name: 'SPP',   tz: 'America/Chicago',      lat: 36.5,  lon: -96.9  },
  ];

  const DAY_MS = 86400000;

  // ====== UTILITIES ======
  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const clamp = (v,min,max)=> Math.min(max,Math.max(min,v));
  const fmt = (n,d=0)=> n?.toLocaleString(undefined,{maximumFractionDigits:d,minimumFractionDigits:d});

  function isoLocal(date, tz){
    const f = new Intl.DateTimeFormat('en-CA',{timeZone:tz,year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',hour12:false});
    const p = Object.fromEntries(f.formatToParts(date).map(x=>[x.type,x.value]));
    return `${p.year}-${p.month}-${p.day}T${p.hour}`; // YYYY-MM-DDTHH
  }
  function byDayKey(d, tz){
    const f = new Intl.DateTimeFormat('en-CA',{timeZone:tz,year:'numeric',month:'2-digit',day:'2-digit'});
    const p = Object.fromEntries(f.formatToParts(d).map(x=>[x.type,x.value]));
    return `${p.year}-${p.month}-${p.day}`;
  }

  // LocalStorage cache helpers
  function getCache(key, maxAgeMs){
    try{
      const raw = localStorage.getItem(key);
      if(!raw) return null;
      const {ts, data} = JSON.parse(raw);
      if(Date.now()-ts > maxAgeMs) return null;
      return data;
    }catch{ return null; }
  }
  function setCache(key, data){
    try{ localStorage.setItem(key, JSON.stringify({ts:Date.now(), data})); }catch{}
  }

  // ====== DOMAIN-AWARE FETCHERS (Throttle & Retry) ======
  let EIA_NEXT_ALLOWED = 0; // global rate limit gate for api.eia.gov
  const EIA_MIN_GAP = 1500;  // ms between EIA calls (soft throttle)
  async function eiaFetch(url, opts={}){
    const now = Date.now();
    const wait = Math.max(0, EIA_NEXT_ALLOWED - now);
    if (wait) { try { __STATUS(`EIA: waiting ${Math.ceil(wait/1000)}s (rate limit)`); } catch(_){}; await sleep(wait); }
    const res = await fetch(url, { cache:'no-store', mode:'cors', ...opts });
    if (res.status === 429){
      const ra = Number(res.headers.get('Retry-After')) || 15;
      EIA_NEXT_ALLOWED = Date.now() + ra*1000 + 250; // add a small buffer
    } else {
      EIA_NEXT_ALLOWED = Date.now() + EIA_MIN_GAP;
    }
    return res;
  }

  let WX_NEXT_ALLOWED = 0;
  const WX_MIN_GAP = 6000; // 6s between weather calls (gentle for shared-IP hosting)
  async function wxFetch(url, opts={}){
    const now = Date.now();
    const wait = Math.max(0, WX_NEXT_ALLOWED - now);
    if (wait) { try { __STATUS(`Weather: waiting ${Math.ceil(wait/1000)}s (rate limit)`); } catch(_){}; await sleep(wait); }
    const res = await fetch(url, { cache:'no-store', mode:'cors', ...opts });
    if (res.status === 429){
      const ra = Number(res.headers.get('Retry-After')) || 10;
      WX_NEXT_ALLOWED = Date.now() + ra*1000 + 250;
    } else {
      WX_NEXT_ALLOWED = Date.now() + WX_MIN_GAP;
    }
    return res;
  }

  async function fetchWithRetry(url, opts={}, {retries=5, base=700, maxDelay=6000}={}){
    const isEIA = url.includes('api.eia.gov');
    const isOM  = url.includes('api.open-meteo.com');
    let attempt = 0;
    const maxRetries = (isEIA || isOM) ? Math.min(retries, 2) : retries; // keep external API retries low
    while(true){
      try{
        const res = await (isEIA ? eiaFetch(url, opts) : isOM ? wxFetch(url, opts) : fetch(url, {cache:'no-store', mode:'cors', ...opts}));
        if(res.status===429){
          const ra = Number(res.headers.get('Retry-After')) || (isEIA?15:20);
          try { __STATUS(`${isEIA?'EIA':'Weather'}: 429, retrying in ${ra}s`); } catch(_){ }
          attempt++; if(attempt>maxRetries) throw new Error('429 Too Many Requests');
          await sleep(ra*1000);
          continue;
        }
        if(res.status>=500){
          attempt++; if(attempt>maxRetries) throw new Error(`Server ${res.status}`);
          await sleep(clamp(base*Math.pow(1.7,attempt), base, maxDelay)); continue;
        }
        if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        const ct = res.headers.get('content-type')||'';
        return ct.includes('application/json') ? await res.json() : await res.text();
      }catch(err){
        attempt++;
        if(attempt>maxRetries) throw err;
        await sleep(clamp(base*Math.pow(1.7,attempt), base, maxDelay));
      }
    }
  }

  // ====== DATA LAYERS ======
  function tzOffsetHM(tz, d){
    try{
      const parts = new Intl.DateTimeFormat('en-US', { timeZone: tz, timeZoneName: 'shortOffset', year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', hour12:false }).formatToParts(d);
      const name = parts.find(p=>p.type==='timeZoneName')?.value || 'UTC+0';
      const m = name.match(/([+-])([0-9]{1,2})(?::?([0-9]{2}))?/);
      if(!m) return '+00:00';
      const sign = m[1];
      const hh = String(Math.abs(parseInt(m[2],10))).padStart(2,'0');
      const mm = String(Math.abs(parseInt(m[3]||'0',10))).padStart(2,'0');
      return `${sign}${hh}:${mm}`; // ¬±HH:MM
    }catch{ return '+00:00'; }
  }

  async function fetchEIAHourly({ba, apiKey}){
    const tz = (ISOS.find(x=>x.id===ba)?.tz) || 'America/New_York';
    const now = new Date();
    const endUTC = now.toISOString().slice(0,13);              // YYYY-MM-DDTHH
    const startUTC = new Date(now.getTime()-8*DAY_MS).toISOString().slice(0,13);
    const off = tzOffsetHM(tz, now);                            // ¬±HH:MM

    const base = 'https://api.eia.gov/v2/electricity/rto';

    const toUTC = d => d.toISOString().slice(0,13);
    const parseUTC = s => new Date(`${s}:00:00Z`);

    function uniqSort(rows){
      const map = new Map();
      for(const r of rows){
        const ts = +new Date(r.t);
        if(!map.has(ts)) map.set(ts, r);
      }
      return [...map.values()].sort((a,b)=>a.t-b.t);
    }

    async function regionUTCChunked(){
      const out = [];
      let cur = parseUTC(startUTC);
      const end = parseUTC(endUTC);
      while(cur < end){
        const next = new Date(Math.min(end.getTime(), cur.getTime() + 48*3600*1000)); // 2‚Äëday chunks
        const p = new URLSearchParams();
        p.set('api_key', apiKey);
        p.set('frequency', 'hourly');
        p.append('data[]','value'); p.append('data[]','period');
        p.append('facets[respondent][]', ba); p.append('facets[type][]','D');
        p.set('start', toUTC(cur)); p.set('end', toUTC(next));
        p.append('sort[0][column]','period'); p.append('sort[0][direction]','asc');
        const url = `${base}/region-data/data/?${p.toString()}`;
        const j = await fetchWithRetry(url);
        const rows = j?.response?.data || [];
        for(const r of rows){ out.push({ t:new Date(r.period), mw:Number(r.value) }); }
        cur = next; await sleep(500);
      }
      return uniqSort(out);
    }

    async function regionLocalChunked(){
      const out = [];
      let cur = new Date(now.getTime()-8*DAY_MS);
      const end = now;
      while(cur < end){
        const next = new Date(Math.min(end.getTime(), cur.getTime() + 48*3600*1000));
        const p = new URLSearchParams();
        p.set('api_key', apiKey);
        p.set('frequency', 'local-hourly');
        p.append('data[]','value'); p.append('data[]','period');
        p.append('facets[respondent][]', ba); p.append('facets[type][]','D');
        // NOTE: For frequency=local-hourly, EIA expects local time WITHOUT an explicit offset.
        p.set('start', isoLocal(cur, tz));
        p.set('end',   isoLocal(next, tz));
        p.append('sort[0][column]','period'); p.append('sort[0][direction]','asc');
        const url = `${base}/region-data/data/?${p.toString()}`;
        const j = await fetchWithRetry(url);
        const rows = j?.response?.data || [];
        for(const r of rows){ out.push({ t:new Date(r.period), mw:Number(r.value) }); }
        cur = next; await sleep(500);
      }
      return uniqSort(out);
    }

    async function trySeriesID(){
      // Legacy v1 fallback ‚Äî only used if v2 routes fail completely
      const SERIES = {
        CISO:'EBA.CISO-ALL.D.H', ERCO:'EBA.ERCO-ALL.D.H', MISO:'EBA.MISO-ALL.D.H', PJM:'EBA.PJM-ALL.D.H',
        NYIS:'EBA.NYIS-ALL.D.H', ISNE:'EBA.ISNE-ALL.D.H', SWPP:'EBA.SPP-ALL.D.H' // NOTE: SPP, not SWPP, on v1
      };
      const sid = SERIES[ba];
      if(!sid) throw new Error(`No series mapping for ${ba}`);
      const p = new URLSearchParams({ api_key: apiKey, series_id: sid, num:'400', out:'json' });
      const url = `https://api.eia.gov/series/?${p.toString()}`;
      const j = await fetchWithRetry(url);
      const rows = j?.series?.[0]?.data || [];
      const parseTs = (s)=>{
        if(typeof s !== 'string') return new Date(s);
        if (s.length >= 13 && s[4]==='-' && s[7]==='-' && s[10]==='T') return new Date(s);
        if (s.length===13 && s[8]==='T' && s.endsWith('Z')){
          const y = s.slice(0,4), m=s.slice(4,6), d=s.slice(6,8), hh=s.slice(9,11);
          return new Date(`${y}-${m}-${d}T${hh}:00:00Z`);
        }
        return new Date(s);
      };
      const out = Array.isArray(rows)
        ? rows.map(r=> Array.isArray(r) ? { t: parseTs(r[0]), mw: Number(r[1]) } : { t: parseTs(r.period), mw: Number(r.value) })
        : [];
      if(!out.length) throw new Error('Empty SeriesID return');
      __STATUS(`EIA ${ba}: series (v1)`);
      return out.sort((a,b)=>a.t-b.t);
    }

    // Preferred order: v2 UTC chunked ‚Üí v2 local chunked ‚Üí v1 series fallback
    try { const u = await regionUTCChunked();   if(u.length){ __STATUS(`EIA ${ba}: UTC (chunked)`);   return u; } } catch(eu){ console.warn('UTC chunked failed', eu); }
    try { const l = await regionLocalChunked(); if(l.length){ __STATUS(`EIA ${ba}: local (chunked)`); return l; } } catch(el){ console.warn('Local chunked failed', el); }
    try { const s = await trySeriesID();        if(s.length){ return s; } } catch(es){ console.warn('SeriesID fallback failed', es); }

    throw new Error('No data after all fallbacks');
  }

  async function fetchWeatherOpenMeteo({lat, lon, tz}){
    const params = new URLSearchParams({
      latitude: lat, longitude: lon,
      hourly: 'temperature_2m',
      daily: 'temperature_2m_max,temperature_2m_min',
      temperature_unit: 'fahrenheit',
      past_days: '7',
      forecast_days: '10',
      timezone: tz
    });
    if (PROXY_BASE) {
      try {
        const url = `${PROXY_BASE}/wx?${params.toString()}`;
        const json = await fetchWithRetry(url);
        const hourly = (json.hourly?.time||[]).map((iso,i)=>({ t:new Date(iso), temp: json.hourly.temperature_2m[i] }));
        const daily = (json.daily?.time||[]).map((d,i)=>({ day:d, tmin: json.daily.temperature_2m_min[i], tmax: json.daily.temperature_2m_max[i] }));
        __STATUS('Weather: Open‚ÄëMeteo via proxy');
        return { hourly, daily, tz };
      } catch(e){ console.warn('Weather proxy failed; falling back to direct', e); }
    }
    const url = `https://api.open-meteo.com/v1/forecast?${params.toString()}`;
    const json = await fetchWithRetry(url);
    const hourly = (json.hourly?.time||[]).map((iso,i)=>({ t:new Date(iso), temp: json.hourly.temperature_2m[i] }));
    const daily = (json.daily?.time||[]).map((d,i)=>({ day:d, tmin: json.daily.temperature_2m_min[i], tmax: json.daily.temperature_2m_max[i] }));
    __STATUS('Weather: Open‚ÄëMeteo direct');
    return { hourly, daily, tz };
  }

  async function fetchWeatherVisualCrossing({lat, lon, tz}){
    if(!WX_API_KEY){ __STATUS('Weather: Visual Crossing key missing, falling back to Open‚ÄëMeteo'); return await fetchWeatherOpenMeteo({lat, lon, tz}); }
    // Use Timeline API with relative window to cover lookback + outlook
    const base = 'https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline';
    const q = new URLSearchParams({
      unitGroup: 'us',
      include: 'hours,days',
      elements: 'datetime,temp,tempmax,tempmin',
      key: WX_API_KEY,
      contentType: 'json'
    });
    // Relative range: past 7 days to next 10 days
    const url = `${base}/${lat},${lon}?startDate=-7days&endDate=+10days&${q.toString()}`;
    const json = await fetchWithRetry(url);
    const days = json?.days || [];
    const hourly = [];
    for(const d of days){
      for(const h of (d.hours||[])){
        const t = new Date(`${d.datetime.split('T')[0]}T${String(h.datetime).padStart(5,'0')}:00`);
        hourly.push({ t, temp: h.temp });
      }
    }
    const daily = days.map(d=>({ day: (d.datetime||'').slice(0,10), tmin: d.tempmin, tmax: d.tempmax }));
    __STATUS('Weather: Visual Crossing');
    return { hourly, daily, tz };
  }

  async function fetchWeather({lat, lon, tz}){
    if(WX_PROVIDER==='visualcrossing') return await fetchWeatherVisualCrossing({lat, lon, tz});
    return await fetchWeatherOpenMeteo({lat, lon, tz});
  }

  function alignByTimestamp(a, b){
    const mapB = new Map(b.map(o=>[+o.t, o]));
    return a.map(x=> ({ t:x.t, ...x, ...(mapB.get(+x.t)||{}) }));
  }
  function splitLookbackOutlook(series, tz){
    const now = new Date();
    const iso = isoLocal(now, tz)+':00:00';
    const cutoff = new Date(iso);
    const lookbackStart = new Date(cutoff.getTime() - 7*DAY_MS);
    const outlookEnd   = new Date(cutoff.getTime() + 10*DAY_MS);
    const past   = series.filter(d=> d.t>=lookbackStart && d.t<cutoff);
    const future = series.filter(d=> d.t>=cutoff && d.t<=outlookEnd);
    return { past, future, cutoff };
  }

  // ====== Modeling ======
  function fitQuad(xs, ys){
    const n = xs.length; if(n<3) return {a: ys.reduce((s,v)=>s+v,0)/Math.max(n,1), b:0, c:0};
    let Sx=0,Sx2=0,Sx3=0,Sx4=0,Sy=0,Sxy=0,Sx2y=0;
    for(let i=0;i<n;i++){ const x=xs[i], y=ys[i]; const x2=x*x, x3=x2*x, x4=x3*x; Sx+=x; Sx2+=x2; Sx3+=x3; Sx4+=x4; Sy+=y; Sxy+=x*y; Sx2y+=x2*y; }
    const D  = n*(Sx2*Sx4 - Sx3*Sx3) - Sx*(Sx*Sx4 - Sx2*Sx3) + Sx2*(Sx*Sx3 - Sx2*Sx2);
    if(Math.abs(D)<1e-9) return {a:Sy/Math.max(n,1), b:0, c:0};
    const Da = Sy*(Sx2*Sx4 - Sx3*Sx3) - Sx*(Sxy*Sx4 - Sx3*Sx2y) + Sx2*(Sxy*Sx3 - Sx2*Sx2y);
    const Db = n*(Sxy*Sx4 - Sx3*Sx2y) - Sy*(Sx*Sx4 - Sx2*Sx3) + Sx2*(Sx*Sx2y - Sx2*Sxy);
    const Dc = n*(Sx2*Sx2y - Sx3*Sxy) - Sx*(Sx*Sx2y - Sx2*Sxy) + Sy*(Sx*Sx3 - Sx2*Sx2);
    return { a:Da/D, b:Db/D, c:Dc/D };
  }
  const predictQuad = ({a,b,c}, x)=> a + b*x + c*x*x;

  function hourlyModels(demandTemps, tz){
    const byHour = Array.from({length:24}, ()=>({xs:[],ys:[]}));
    for(const r of demandTemps){
      const h = Number(new Intl.DateTimeFormat('en-US',{timeZone:tz,hour:'2-digit',hour12:false}).format(r.t));
      if(Number.isFinite(r.mw) && Number.isFinite(r.temp)){
        byHour[h].xs.push(r.temp); byHour[h].ys.push(r.mw);
      }
    }
    return byHour.map(({xs,ys})=>fitQuad(xs,ys));
  }
  function forecastDemand(models, temps, tz){
    return temps.map(pt=>{
      const h = Number(new Intl.DateTimeFormat('en-US',{timeZone:tz,hour:'2-digit',hour12:false}).format(pt.t));
      const m = models[h] || {a:0,b:0,c:0};
      const y = predictQuad(m, pt.temp);
      return { t:pt.t, mw: Math.max(0, Number.isFinite(y)? y : 0) };
    });
  }
  const repeatDaily = (values, tz)=>{
    const map = new Map(values.map(v=>[v.day, v]));
    return hours=> hours.map(h=>{ const v = map.get(byDayKey(h.t, tz))||{}; return { t:h.t, tmin:v.tmin, tmax:v.tmax };});
  };

  // ====== UI ======
  function makeCard(iso){
    const el = document.createElement('section');
    el.className = 'card';
    el.innerHTML = `
      <header>
        <div>
          <h2>${iso.name}</h2>
          <div class="meta">BA: ${iso.id} ¬∑ ${iso.tz}</div>
        </div>
        <div class="row small" id="peak-${iso.id}">Predicted peak: ‚Äî</div>
      </header>
      <div class="tabs" role="tablist">
        <button class="tab" role="tab" aria-selected="true" data-tab="lookback-${iso.id}">7‚Äëday lookback</button>
        <button class="tab" role="tab" aria-selected="false" data-tab="outlook-${iso.id}">10‚Äëday outlook</button>
      </div>
      <div class="loading" id="loading-${iso.id}">Loading ${iso.name}‚Ä¶</div>
      <div id="wrap-${iso.id}">
        <div id="lookback-${iso.id}" role="tabpanel">
          <div class="row" style="padding:0 12px 8px">
            <span class="badge"><span class="dot mw"></span> Demand (MW)</span>
            <span class="badge"><span class="dot temp"></span> Temp (¬∞F)</span>
          </div>
          <canvas id="cb-${iso.id}"></canvas>
        </div>
        <div id="outlook-${iso.id}" role="tabpanel" hidden>
          <div class="row" style="padding:0 12px 8px">
            <span class="badge"><span class="dot mw"></span> Predicted Demand (MW)</span>
            <span class="badge"><span class="dot temp"></span> Temp (¬∞F)</span>
            <span class="badge"><span class="dot tmin"></span> Daily Min (¬∞F)</span>
            <span class="badge"><span class="dot tmax"></span> Daily Max (¬∞F)</span>
          </div>
          <canvas id="cf-${iso.id}"></canvas>
        </div>
      </div>`;
    return el;
  }

  function buildLookbackChart(ctx, data){
    const labels = data.map(d=>d.t);
    return new Chart(ctx, {type:'line', data:{labels, datasets:[
      {label:'Demand (MW)', data:data.map(d=>d.mw), yAxisID:'y', borderWidth:1.8, pointRadius:0, borderColor:'#60a5fa', tension:.2},
      {label:'Temp (¬∞F)',   data:data.map(d=>d.temp), yAxisID:'y1', borderWidth:1.2, pointRadius:0, borderColor:'#f87171', tension:.2},
    ]}, options:{interaction:{mode:'index',intersect:false}, scales:{
      x:{type:'time', time:{unit:'day', tooltipFormat:'MMM d, HH:mm'}},
      y:{position:'left', ticks:{ callback:v=>fmt(v) }},
      y1:{position:'right', grid:{drawOnChartArea:false}},
    }}});
  }
  function buildOutlookChart(ctx, demand, tempsHourly, tDaily){
    const labels = demand.map(d=>d.t);
    return new Chart(ctx, {type:'line', data:{labels, datasets:[
      {label:'Predicted Demand (MW)', data:demand.map(d=>d.mw), yAxisID:'y', borderWidth:1.8, pointRadius:0, borderColor:'#60a5fa', tension:.2},
      {label:'Temp (¬∞F)',             data:tempsHourly.map(d=>d.temp), yAxisID:'y1', borderWidth:1.2, pointRadius:0, borderColor:'#f87171', tension:.2},
      {label:'Daily Min (¬∞F)',        data:tDaily.map(d=>d.tmin), yAxisID:'y1', borderDash:[4,4], borderWidth:1, pointRadius:0, borderColor:'#10b981', tension:.1},
      {label:'Daily Max (¬∞F)',        data:tDaily.map(d=>d.tmax), yAxisID:'y1', borderDash:[4,4], borderWidth:1, pointRadius:0, borderColor:'#f59e0b', tension:.1},
    ]}, options:{interaction:{mode:'index',intersect:false}, scales:{
      x:{type:'time', time:{unit:'day', tooltipFormat:'MMM d, HH:mm'}},
      y:{position:'left', ticks:{ callback:v=>fmt(v) }},
      y1:{position:'right', grid:{drawOnChartArea:false}},
    }}});
  }

  function setTabs(card){
    const tabs = card.querySelectorAll('.tab');
    tabs.forEach(btn=>btn.addEventListener('click',()=>{
      tabs.forEach(b=>b.setAttribute('aria-selected','false'));
      btn.setAttribute('aria-selected','true');
      const id = btn.dataset.tab;
      card.querySelectorAll('[role="tabpanel"]').forEach(p=> p.hidden = (p.id!==id));
    }));
  }

  function __STATUS(msg){
    const status = document.getElementById('status');
    if (status) status.textContent = msg;
  }

  async function renderISO(iso, apiKey){
    const grid = document.getElementById('grid');
    const card = makeCard(iso); grid.appendChild(card); setTabs(card);
    const loading = card.querySelector(`#loading-${iso.id}`);

    const kDem = `eia:${iso.id}`;
    const kWx  = `wx:${iso.id}`;
    const demTTL = 30*60*1000, wxTTL=6*60*60*1000; // 30m demand, 6h weather

    // Demand first (hard requirement)
    let demandRows = getCache(kDem, demTTL);
    if(!demandRows){
      try{ demandRows = await fetchEIAHourly({ba: iso.id, apiKey}); setCache(kDem, demandRows); }
      catch(err){ console.error(err); loading.innerHTML = `<span class="err">Demand error: ${err.message}</span>`; return; }
    }

    // Weather (soft requirement)
    let weather = getCache(kWx, wxTTL);
    if(!weather){
      try{ weather = await fetchWeather({lat: iso.lat, lon: iso.lon, tz: iso.tz}); setCache(kWx, weather); }
      catch(err){ console.warn('Weather failed', err); weather = null; }
    }

    try{
      const hourlyTemps = weather? weather.hourly : demandRows.map(r=>({ t:r.t, temp: null }));
      const joined = alignByTimestamp(hourlyTemps, demandRows);
      const { past, future } = splitLookbackOutlook(joined, iso.tz);

      // Lookback chart (always render, even if no temps)
      const lookback = past.filter(r=>Number.isFinite(r.mw));
      const cb = card.querySelector(`#cb-${iso.id}`).getContext('2d');
      buildLookbackChart(cb, lookback);

      const outlookPanel = card.querySelector(`#outlook-${iso.id}`);
      const peakEl = card.querySelector(`#peak-${iso.id}`);

      if(weather){
        const models = hourlyModels(lookback.filter(r=>Number.isFinite(r.temp)), iso.tz);
        const futureTemps = future.map(({t,temp})=>({t,temp}));
        const yhat = forecastDemand(models, futureTemps, iso.tz);
        const dailyOnHours = repeatDaily(weather.daily, iso.tz)(futureTemps);
        const cf = card.querySelector(`#cf-${iso.id}`).getContext('2d');
        buildOutlookChart(cf, yhat, futureTemps, dailyOnHours);
        const peak = yhat.reduce((m,pt)=> (pt.mw>m.mw? pt : m), {mw:-Infinity});
        const fmtDT = new Intl.DateTimeFormat([], { timeZone: iso.tz, month:'short', day:'2-digit', hour:'2-digit' });
        peakEl.innerHTML = `Predicted peak: <strong>${fmt(Math.round(peak.mw))} MW</strong> ¬∑ ${fmtDT.format(peak.t)}`;
      } else {
        outlookPanel.innerHTML = `<div class="loading">Weather rate-limited (429). Switch to Visual Crossing (default) or set a proxy in the header.</div>`;
        peakEl.textContent = 'Predicted peak: ‚Äî';
      }
    }catch(err){
      console.error(err);
      loading.innerHTML = `<span class="err">Render error: ${err.message}</span>`;
      return;
    }

    loading.remove();
  }

  function boot(){
    // 1) Populate inputs + status FIRST so key is visible even if charts libs fail
    const eiaInput = document.getElementById('eiaKey');
    const proxyInput = document.getElementById('proxyBase');
    const status = document.getElementById('status');
    const wxProviderSel = document.getElementById('wxProvider');
    const wxKeyInput = document.getElementById('wxKey');

    let key = '';
    let proxy = '';
    try { key = localStorage.getItem('EIA_API_KEY') || ''; proxy = localStorage.getItem('PROXY_BASE') || ''; } catch(_){ /* ignore */ }

    eiaInput.value = key || DEFAULT_EIA_KEY;
    proxyInput.value = proxy;
    wxProviderSel.value = WX_PROVIDER;
    wxKeyInput.value = WX_API_KEY;

    const wxLabel = ` ¬∑ wx=${WX_PROVIDER}${WX_PROVIDER==='visualcrossing' && !WX_API_KEY ? '(no key)' : ''}`;
    status.textContent = (eiaInput.value ? 'Key loaded' : 'Using default key (not saved)') + (proxy? ' + proxy' : '') + wxLabel;

    document.getElementById('save').onclick = ()=>{
      try{
        localStorage.setItem('EIA_API_KEY', eiaInput.value.trim());
        localStorage.setItem('PROXY_BASE', proxyInput.value.trim());
        localStorage.setItem('WX_PROVIDER', wxProviderSel.value);
        localStorage.setItem('WX_API_KEY', wxKeyInput.value.trim());
        status.textContent = 'Saved';
        location.reload();
      }catch(e){ status.textContent = 'Save failed: ' + e.message; }
    };

    const effectiveKey = (eiaInput.value || '').trim();
    if(!effectiveKey){ status.innerHTML = '<span class="small">Paste your EIA key to fetch demand.</span>'; return; }

    try { assertLibs(); } catch (e) { status.textContent = `Libraries failed: ${e.message}`; console.error(e); return; }

    (async ()=>{
      for(const iso of ISOS){
        await renderISO(iso, effectiveKey);
        await sleep(6000);
      }
    })();

    const now = new Date(); const midnight = new Date(now); midnight.setHours(24,5,0,0);
    setTimeout(()=>location.reload(), midnight - now);
  }

  window.addEventListener('load', boot);
  </script>
</body>
</html>
