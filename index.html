<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NA ISO Demand â€” 7â€‘Day Lookback & 10â€‘Day Outlook</title>
  <meta name="description" content="Auto-updating dashboard showing 7-day lookback of hourly electric demand and a 10-day temperature-driven demand outlook for major North American ISOs (US)." />
  <style>
    :root{
      --bg:#0b0c10; --panel:#111318; --muted:#9aa3af; --text:#f1f5f9; --accent:#60a5fa;
      --good:#34d399; --warn:#f59e0b; --bad:#ef4444; --grid:16px; --card:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;background:var(--bg);color:var(--text)}
    header{padding:18px 16px;border-bottom:1px solid #1f2430;background:linear-gradient(180deg,#0f1117, #0b0c10)}
    h1{margin:0;font-size:clamp(16px,2.3vw,22px);letter-spacing:.3px}
    .sub{color:var(--muted);font-size:12.5px;margin-top:6px}
    .controls{display:flex;gap:12px;flex-wrap:wrap;margin-top:14px;align-items:center}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:8px 10px;border:1px solid #1f2430;border-radius:10px;background:#0d1016;color:var(--text)}
    .pill input{background:transparent;border:none;color:var(--text);outline:none;min-width:240px}
    .btn{cursor:pointer;border:1px solid #1f2430;border-radius:10px;background:#0d1016;color:var(--text);padding:8px 10px}
    .btn:hover{background:#131722}
    .grid{display:grid;gap:14px;padding:16px;grid-template-columns:repeat(auto-fill,minmax(360px,1fr))}
    .card{background:var(--panel);border:1px solid #1f2430;border-radius:16px;overflow:hidden;display:flex;flex-direction:column;min-height:420px}
    .card header{display:flex;align-items:center;justify-content:space-between;background:transparent;border:0;padding:12px 12px 0 12px}
    .card h2{font-size:16px;margin:0}
    .meta{color:var(--muted);font-size:12px}
    .tabs{display:flex;gap:6px;padding:0 12px 8px}
    .tab{flex:0 0 auto;padding:7px 9px;border-radius:999px;border:1px solid #1f2430;background:#0d1016;color:var(--text);cursor:pointer;font-size:12px}
    .tab[aria-selected="true"]{background:#122031;border-color:#1e3a8a;color:#cfe1ff}
    canvas{display:block;width:100%;height:300px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .badge{display:inline-flex;align-items:center;gap:6px;background:#0d1016;border:1px solid #1f2430;border-radius:999px;padding:6px 8px;color:#cbd5e1;font-size:12px}
    .dot{width:8px;height:8px;border-radius:50%}
    .dot.mw{background:var(--accent)}
    .dot.temp{background:#f87171}
    .dot.tmin{background:#10b981}
    .dot.tmax{background:#f59e0b}
    footer{padding:16px;color:var(--muted);font-size:12px;text-align:center}
    .warn{color:#ffd089}
    .err{color:#ff8a8a}
    .loading{padding:12px 12px 8px}
    .small{font-size:11px;color:#9aa3af}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"></script>
</head>
<body>
  <header>
    <h1>NA ISO Demand â€” 7â€‘Day Lookback & 10â€‘Day Outlook</h1>
    <div class="sub">Live hourly demand (MW) + temperatures (Â°F), plus a temperatureâ€‘based 10â€‘day demand outlook with predicted peak hour for major US ISOs. Autoâ€‘updates when you open it.</div>
    <div class="controls">
      <label class="pill" title="Your free EIA API key">
        <span>ðŸ”‘ EIA API Key</span>
        <input id="eiaKey" placeholder="paste your keyâ€¦" autocomplete="off"/>
      </label>
      <button class="btn" id="saveKey">Save</button>
      <span id="keyStatus" class="small"></span>
      <span class="small">Tip: get a key free at eia.gov/opendata</span>
    </div>
  </header>

  <main class="grid" id="grid"></main>

  <footer>
    Data: EIAâ€‘930 hourly BA operations (demand) + Openâ€‘Meteo hourly temps. Forecast = simple tempâ€‘sensitivity model fitted on last 7 days per ISO/hour. <span class="warn">Strictly informational.</span>
  </footer>

  <script>
  // ======= Configuration =======
  const ISOS = [
    { id: 'CISO', name: 'CAISO', tz: 'America/Los_Angeles', lat: 36.77, lon: -119.42 },
    { id: 'ERCO', name: 'ERCOT', tz: 'America/Chicago', lat: 31.0, lon: -99.0 },
    { id: 'MISO', name: 'MISO', tz: 'America/Chicago', lat: 41.0, lon: -93.0 },
    { id: 'PJM',  name: 'PJM',  tz: 'America/New_York', lat: 39.8, lon: -77.0 },
    { id: 'NYIS', name: 'NYISO', tz: 'America/New_York', lat: 42.9, lon: -75.0 },
    { id: 'ISNE', name: 'ISOâ€‘NE', tz: 'America/New_York', lat: 42.36, lon: -71.06 },
    { id: 'SWPP', name: 'SPP', tz: 'America/Chicago', lat: 36.5, lon: -96.9 },
  ];

  const DAY_MS = 86400000;

  function fmt(n, digits=0){
    return n?.toLocaleString(undefined,{maximumFractionDigits:digits, minimumFractionDigits:digits});
  }

  function isoLocal(date, tz){
    // Return YYYY-MM-DDTHH for the given tz
    const f = new Intl.DateTimeFormat('en-CA', { timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', hour12:false });
    const parts = Object.fromEntries(f.formatToParts(date).map(p=>[p.type,p.value]));
    return `${parts.year}-${parts.month}-${parts.day}T${parts.hour}`;
  }

  function byDayKey(d, tz){
    const f = new Intl.DateTimeFormat('en-CA', { timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit' });
    const parts = Object.fromEntries(f.formatToParts(d).map(p=>[p.type,p.value]));
    return `${parts.year}-${parts.month}-${parts.day}`;
  }

  // Simple Quadratic Fit y = a + b*T + c*T^2 for a single hour-of-day
  function fitQuad(xs, ys){
    const n = xs.length; if(n < 3) return {a: ys.reduce((s,v)=>s+v,0)/Math.max(n,1), b:0, c:0};
    let Sx=0,Sx2=0,Sx3=0,Sx4=0,Sy=0,Sxy=0,Sx2y=0;
    for(let i=0;i<n;i++){
      const x=xs[i], y=ys[i];
      const x2 = x*x; const x3=x2*x; const x4=x3*x;
      Sx+=x; Sx2+=x2; Sx3+=x3; Sx4+=x4; Sy+=y; Sxy+=x*y; Sx2y+=x2*y;
    }
    // Solve 3x3 normal equations using Cramer's rule
    const D = n*(Sx2*Sx4 - Sx3*Sx3) - Sx*(Sx*Sx4 - Sx2*Sx3) + Sx2*(Sx*Sx3 - Sx2*Sx2);
    if(Math.abs(D) < 1e-9){
      return {a: Sy/Math.max(n,1), b:0, c:0};
    }
    const Da = Sy*(Sx2*Sx4 - Sx3*Sx3) - Sx*(Sxy*Sx4 - Sx3*Sx2y) + Sx2*(Sxy*Sx3 - Sx2*Sx2y);
    const Db = n*(Sxy*Sx4 - Sx3*Sx2y) - Sy*(Sx*Sx4 - Sx2*Sx3) + Sx2*(Sx*Sx2y - Sx2*Sxy);
    const Dc = n*(Sx2*Sx2y - Sx3*Sxy) - Sx*(Sx*Sx2y - Sx2*Sxy) + Sy*(Sx*Sx3 - Sx2*Sx2);
    return { a: Da/D, b: Db/D, c: Dc/D };
  }

  function predictQuad({a,b,c}, x){ return a + b*x + c*x*x; }

  async function fetchEIAHourly({ba, apiKey, hours=5000}){
    const url = `https://api.eia.gov/v2/electricity/rto/region-data/data/?api_key=${encodeURIComponent(apiKey)}`;
    const xparams = {
      frequency: 'hourly',
      data: ['value','period','respondent','type'],
      facets: { respondent: [ba], type: ['D'] },
      sort: [{ column: 'period', direction: 'desc' }],
      length: Math.min(hours, 5000)
    };
    const res = await fetch(url, { headers: { 'X-Params': JSON.stringify(xparams) }});
    if(!res.ok) throw new Error(`EIA error ${res.status}`);
    const json = await res.json();
    const rows = json?.response?.data || [];
    // Normalize to ascending time order
    rows.reverse();
    return rows.map(r=>({ t: new Date(r.period), mw: Number(r.value) }));
  }

  async function fetchWeather({lat, lon, tz}){
    // Past 7 days + next 10 days hourly temps (Â°F) and daily min/max
    const params = new URLSearchParams({
      latitude: lat, longitude: lon,
      hourly: 'temperature_2m',
      daily: 'temperature_2m_max,temperature_2m_min',
      temperature_unit: 'fahrenheit',
      past_days: '7',
      forecast_days: '10',
      timezone: tz
    });
    const url = `https://api.open-meteo.com/v1/forecast?${params.toString()}`;
    const res = await fetch(url);
    if(!res.ok) throw new Error(`Weather error ${res.status}`);
    const wx = await res.json();
    const hourly = (wx.hourly?.time || []).map((iso, i)=>({ t: new Date(iso), temp: wx.hourly.temperature_2m[i] }));
    const daily = (wx.daily?.time || []).map((d, i)=>({ day: d, tmin: wx.daily.temperature_2m_min[i], tmax: wx.daily.temperature_2m_max[i] }));
    return { hourly, daily, tz };
  }

  function alignByTimestamp(a, b){
    // Join arrays by timestamp (Date.getTime())
    const mapB = new Map(b.map(o=>[+o.t, o]));
    return a.map(x=> ({ t: x.t, ...x, ...(mapB.get(+x.t) || {}) }));
  }

  function splitLookbackOutlook(series, tz){
    const now = new Date();
    // Start of current hour in tz
    const iso = isoLocal(now, tz) + ':00:00';
    const cutoff = new Date(iso);
    const lookbackStart = new Date(cutoff.getTime() - 7*DAY_MS);
    const outlookEnd = new Date(cutoff.getTime() + 10*DAY_MS);
    const past = series.filter(d => d.t >= lookbackStart && d.t < cutoff);
    const future = series.filter(d => d.t >= cutoff && d.t <= outlookEnd);
    return { past, future, cutoff };
  }

  function hourlyModels(demandTemps, tz){
    // demandTemps: [{t, mw, temp}] over the past 7 days. Build a quadratic model for each hour-of-day.
    const byHour = Array.from({length:24}, ()=>({xs:[],ys:[]}));
    for(const row of demandTemps){
      const h = Number(new Intl.DateTimeFormat('en-US',{timeZone:tz, hour:'2-digit', hour12:false}).format(row.t));
      if(isFinite(row.mw) && isFinite(row.temp)){
        byHour[h].xs.push(row.temp);
        byHour[h].ys.push(row.mw);
      }
    }
    return byHour.map(({xs,ys})=>fitQuad(xs,ys));
  }

  function forecastDemand(models, temps, tz){
    // temps: hourly future temps [{t,temp}]
    return temps.map(pt=>{
      const h = Number(new Intl.DateTimeFormat('en-US',{timeZone:tz, hour:'2-digit', hour12:false}).format(pt.t));
      const m = models[h] || {a:0,b:0,c:0};
      let y = predictQuad(m, pt.temp);
      if(!isFinite(y)) y = NaN;
      return { t: pt.t, mw: Math.max(0, y) };
    });
  }

  function repeatDaily(values, tz){
    // Expand day-based array into hourly by repeating within each day across hours present in a reference list
    const map = new Map(values.map(v=>[v.day, v]));
    return (hours)=> hours.map(h=>{
      const dayKey = byDayKey(h.t, tz);
      const v = map.get(dayKey) || {};
      return { t: h.t, tmin: v.tmin, tmax: v.tmax };
    });
  }

  function makeCard(iso){
    const el = document.createElement('section');
    el.className = 'card';
    el.innerHTML = `
      <header>
        <div>
          <h2>${iso.name}</h2>
          <div class="meta">BA: ${iso.id} Â· ${iso.tz}</div>
        </div>
        <div class="row small" id="peak-${iso.id}">Predicted peak: â€”</div>
      </header>
      <div class="tabs" role="tablist">
        <button class="tab" role="tab" aria-selected="true" data-tab="lookback-${iso.id}">7â€‘day lookback</button>
        <button class="tab" role="tab" aria-selected="false" data-tab="outlook-${iso.id}">10â€‘day outlook</button>
      </div>
      <div class="loading" id="loading-${iso.id}">Loading ${iso.name}â€¦</div>
      <div id="wrap-${iso.id}">
        <div id="lookback-${iso.id}" role="tabpanel">
          <div class="row" style="padding:0 12px 8px">
            <span class="badge"><span class="dot mw"></span> Demand (MW)</span>
            <span class="badge"><span class="dot temp"></span> Temp (Â°F)</span>
          </div>
          <canvas id="cb-${iso.id}"></canvas>
        </div>
        <div id="outlook-${iso.id}" role="tabpanel" hidden>
          <div class="row" style="padding:0 12px 8px">
            <span class="badge"><span class="dot mw"></span> Predicted Demand (MW)</span>
            <span class="badge"><span class="dot temp"></span> Temp (Â°F)</span>
            <span class="badge"><span class="dot tmin"></span> Daily Min (Â°F)</span>
            <span class="badge"><span class="dot tmax"></span> Daily Max (Â°F)</span>
          </div>
          <canvas id="cf-${iso.id}"></canvas>
        </div>
      </div>
    `;
    return el;
  }

  function lineColor(ctx, name){
    const colors = { demand: '#60a5fa', temp:'#f87171', tmin:'#10b981', tmax:'#f59e0b' };
    return colors[name] || '#93c5fd';
  }

  function buildLookbackChart(ctx, data){
    const labels = data.map(d=>d.t);
    return new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [
          { label: 'Demand (MW)', data: data.map(d=>d.mw), yAxisID:'y', borderWidth:1.8, pointRadius:0, borderColor: lineColor(null,'demand'), tension:.2 },
          { label: 'Temp (Â°F)', data: data.map(d=>d.temp), yAxisID:'y1', borderWidth:1.2, pointRadius:0, borderColor: lineColor(null,'temp'), tension:.2 },
        ]
      },
      options: {
        interaction:{mode:'index',intersect:false},
        scales: {
          x: { type:'time', time:{ unit:'day', tooltipFormat:'MMM d, HH:mm' }, grid:{ color:'#1f2430' }, ticks:{ color:'#9aa3af' } },
          y: { position:'left', grid:{ color:'#1f2430' }, ticks:{ color:'#9aa3af', callback:v=>fmt(v) } },
          y1:{ position:'right', grid:{ drawOnChartArea:false }, ticks:{ color:'#9aa3af' } }
        },
        plugins:{ legend:{labels:{color:'#cbd5e1'}}, tooltip:{ callbacks:{ label(ctx){ return `${ctx.dataset.label}: ${fmt(ctx.parsed.y, ctx.dataset.yAxisID==='y'?0:1)}`; } } } }
      }
    });
  }

  function buildOutlookChart(ctx, demand, tempsHourly, tDaily){
    const labels = demand.map(d=>d.t);
    return new Chart(ctx, {
      type: 'line',
      data:{
        labels,
        datasets:[
          { label:'Predicted Demand (MW)', data:demand.map(d=>d.mw), yAxisID:'y', borderWidth:1.8, pointRadius:0, borderColor:lineColor(null,'demand'), tension:.2 },
          { label:'Temp (Â°F)', data:tempsHourly.map(d=>d.temp), yAxisID:'y1', borderWidth:1.2, pointRadius:0, borderColor:lineColor(null,'temp'), tension:.2 },
          { label:'Daily Min (Â°F)', data:tDaily.map(d=>d.tmin), yAxisID:'y1', borderDash:[4,4], borderWidth:1, pointRadius:0, borderColor:lineColor(null,'tmin'), tension:.1 },
          { label:'Daily Max (Â°F)', data:tDaily.map(d=>d.tmax), yAxisID:'y1', borderDash:[4,4], borderWidth:1, pointRadius:0, borderColor:lineColor(null,'tmax'), tension:.1 }
        ]
      },
      options: {
        interaction:{mode:'index',intersect:false},
        scales: {
          x: { type:'time', time:{ unit:'day', tooltipFormat:'MMM d, HH:mm' }, grid:{ color:'#1f2430' }, ticks:{ color:'#9aa3af' } },
          y: { position:'left', grid:{ color:'#1f2430' }, ticks:{ color:'#9aa3af', callback:v=>fmt(v) } },
          y1:{ position:'right', grid:{ drawOnChartArea:false }, ticks:{ color:'#9aa3af' } }
        },
        plugins:{ legend:{labels:{color:'#cbd5e1'}}, tooltip:{ callbacks:{ label(ctx){ return `${ctx.dataset.label}: ${fmt(ctx.parsed.y, ctx.dataset.yAxisID==='y'?0:1)}`; } } } }
      }
    });
  }

  function setTabs(card){
    const tabs = card.querySelectorAll('.tab');
    tabs.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        tabs.forEach(b=>b.setAttribute('aria-selected','false'));
        btn.setAttribute('aria-selected','true');
        const id = btn.dataset.tab;
        card.querySelectorAll('[role="tabpanel"]').forEach(p=> p.hidden = (p.id !== id));
      });
    });
  }

  async function renderISO(iso, apiKey){
    const grid = document.getElementById('grid');
    const card = makeCard(iso);
    grid.appendChild(card);
    setTabs(card);

    try{
      const [demandRows, weather] = await Promise.all([
        fetchEIAHourly({ba: iso.id, apiKey}),
        fetchWeather({lat: iso.lat, lon: iso.lon, tz: iso.tz})
      ]);

      // Align demand with temps over the union range
      const allTemps = weather.hourly; // past + future
      const joined = alignByTimestamp(allTemps, demandRows);
      const { past, future } = splitLookbackOutlook(joined, iso.tz);

      // Build lookback chart (only hours with demand)
      const lookback = past.filter(r=>Number.isFinite(r.mw) && Number.isFinite(r.temp));
      const cb = card.querySelector(`#cb-${iso.id}`).getContext('2d');
      buildLookbackChart(cb, lookback);

      // Forecast using hour-of-day quadratic models on past 7d
      const models = hourlyModels(lookback, iso.tz);
      const futureTemps = future.map(({t,temp})=>({t,temp}));
      const yhat = forecastDemand(models, futureTemps, iso.tz);

      // Daily min/max expanded to hourly timestamps
      const expandDaily = repeatDaily(weather.daily, iso.tz);
      const dailyOnHours = expandDaily(futureTemps);

      // Outlook chart
      const cf = card.querySelector(`#cf-${iso.id}`).getContext('2d');
      buildOutlookChart(cf, yhat, futureTemps, dailyOnHours);

      // Peak hour badge
      const peak = yhat.reduce((m,pt)=> (pt.mw>m.mw? pt : m), {mw:-Infinity});
      const fmtDT = new Intl.DateTimeFormat([], { timeZone: iso.tz, month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit' });
      const peakEl = card.querySelector(`#peak-${iso.id}`);
      peakEl.innerHTML = `Predicted peak: <strong>${fmt(Math.round(peak.mw))} MW</strong> Â· ${fmtDT.format(peak.t)} (${iso.tz.split('/')[1]||iso.tz})`;

    }catch(err){
      console.error(err);
      const loading = card.querySelector(`#loading-${iso.id}`);
      loading.innerHTML = `<span class="err">${err.message}</span> â€” Check your EIA API key and network.`;
      return;
    }

    // Hide loader
    const loading = card.querySelector(`#loading-${iso.id}`);
    if(loading) loading.remove();
  }

  function boot(){
    // Prefill & persist API key
    const input = document.getElementById('eiaKey');
    const saveBtn = document.getElementById('saveKey');
    const status = document.getElementById('keyStatus');
    const saved = localStorage.getItem('EIA_API_KEY') || '';
    if(saved){ input.value = saved; status.textContent = 'Key loaded'; }
    saveBtn.onclick = ()=>{ localStorage.setItem('EIA_API_KEY', input.value.trim()); status.textContent = 'Saved'; location.reload(); };

    const key = (input.value||'').trim();
    if(!key){
      status.innerHTML = '<span class="warn">No EIA key set â€” paste yours to fetch demand.</span>';
      return; // Don\'t render until key provided
    }

    ISOS.forEach(iso=> renderISO(iso, key));

    // Auto refresh shortly after midnight local (per user browser) to roll windows
    const now = new Date();
    const midnight = new Date(now); midnight.setHours(24,5,0,0); // 12:05am next day
    setTimeout(()=>location.reload(), midnight - now);
  }

  // Load Chart.js time scale adapter
  (function ensureTimeScale(){
    const s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/luxon@3.5.0/build/global/luxon.min.js';
    s.onload = ()=>{
      const t = document.createElement('script');
      t.src = 'https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.3/dist/chartjs-adapter-luxon.umd.min.js';
      t.onload = boot; document.head.appendChild(t);
    };
    document.head.appendChild(s);
  })();
  </script>
</body>
</html>
